<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="google-site-verification" content="K1XZmOE_EW273ZVmq5GQXfl_QDyMzcHliFZ2L33zr84" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="I am a weak SDN postgraduate, however, I love coding.">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Java基础汇总（持续更新……） - BlackSide的博客 | BlackSide&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> I am a weak postgraduate doing SDN, however, I love coding. </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/author.jpeg" />
        </div>
        <div class="name">
            <i>BlackSide Fan</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java重载、重写与隐藏"><span class="toc-text">1. Java重载、重写与隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-构造方法"><span class="toc-text">2. 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-访问修饰符"><span class="toc-text">3. 访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-接口、抽象类及它们的联系与区别"><span class="toc-text">4. 接口、抽象类及它们的联系与区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-析构函数"><span class="toc-text">5. 析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-JDK中常用的包与功能"><span class="toc-text">6. JDK中常用的包与功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-super和this关键字"><span class="toc-text">7. super和this关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Object类的基本方法"><span class="toc-text">8. Object类的基本方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-final关键字"><span class="toc-text">9. final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-J2EE常见名词"><span class="toc-text">10. J2EE常见名词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-加载驱动的三种方式"><span class="toc-text">11. 加载驱动的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-静态方法、静态变量、静态代码块"><span class="toc-text">12. 静态方法、静态变量、静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Java表达式转型规则"><span class="toc-text">13. Java表达式转型规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-基本数据类型和引用数据类型"><span class="toc-text">14. 基本数据类型和引用数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Java变量初始值问题"><span class="toc-text">15. Java变量初始值问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Java的四种引用"><span class="toc-text">16. Java的四种引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Java序列化"><span class="toc-text">17. Java序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-类型转换"><span class="toc-text">18. 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-多态"><span class="toc-text">19. 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-数组"><span class="toc-text">20. 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-Comparable和Comparator的区别"><span class="toc-text">21. Comparable和Comparator的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-类的生命周期以及双亲委托机制"><span class="toc-text">22. 类的生命周期以及双亲委托机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-动态绑定和静态绑定"><span class="toc-text">23. 动态绑定和静态绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-HashMap"><span class="toc-text">24. HashMap</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> I am a weak postgraduate doing SDN, however, I love coding. </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Java基础汇总（持续更新……）
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-06-22 15:01:32</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#Java" title="Java">Java</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p>参考资料：<a href="https://blog.csdn.net/cheidou123/article/details/95041367" target="_blank" rel="noopener">https://blog.csdn.net/cheidou123/article/details/95041367</a></p>
</blockquote>
<h3 id="1-Java重载、重写与隐藏"><a href="#1-Java重载、重写与隐藏" class="headerlink" title="1. Java重载、重写与隐藏"></a>1. Java重载、重写与隐藏</h3><ul>
<li>重载（overload）：类中多态性的表现。<ul>
<li>根据方法参数列表中的参数类型或参数个数；</li>
<li>不可以基于方法的返回值类型。</li>
</ul>
</li>
<li>重写（override）：<ul>
<li>“两小”：子类方法的返回值类型、抛出的异常均小于父类方法的；</li>
<li>“两同”：子类方法的方法名和参数列表均与父类方法的相同；</li>
<li>“一大”：子类方法的访问权限应大于父类方法的。</li>
</ul>
</li>
<li>隐藏：针对父类的成员变量或静态方法。<ul>
<li>子类声明了与父类相同的变量时，父类的同名变量被隐藏；</li>
<li>子类声明了与父类同名的静态方法、且方法的参数列表与返回值类型均与父类方法相同时，父类的同名静态方法被隐藏。</li>
</ul>
</li>
</ul>
<h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h3><ul>
<li>与类名相同；</li>
<li>没有返回类型，也不能为<code>void</code>；</li>
<li>完成对象的初始化工作，将定义对象时的参数传递给对象的域；</li>
<li>一个类可以定义多个构造方法，若不定义，则会自动生成一个无参数的构造方法，且方法内不执行任何代码；</li>
<li>可以根据参数列表中参数的类型、个数、顺序对构造方法重载；</li>
<li>不能被<code>static</code>、<code>final</code>、<code>synchronized</code>、<code>abstract</code>、<code>native</code>修饰，但可以被<code>private</code>、<code>protected</code>、<code>public</code>修饰；</li>
<li>不能被继承，只能被显式或隐式的调用；</li>
<li>若父类没有无参的构造方法，则子类需在自己的构造方法中显式地调用父类的构造方法；</li>
<li>构造方法每次都是构造新的对象，不存在多个线程同时读写同一个对象中属性的问题，所以不需要同步。</li>
</ul>
<h3 id="3-访问修饰符"><a href="#3-访问修饰符" class="headerlink" title="3. 访问修饰符"></a>3. 访问修饰符</h3><ul>
<li><code>public</code>：当前类、子类、包内、其他包；</li>
<li><code>protected</code>：当前类、子类、包内；</li>
<li><code>default</code>：当前类、包内；</li>
<li><code>private</code>：当前类。</li>
<li><code>private</code>的属性和方法可以被子类继承，但不能被子类调用。</li>
</ul>
<h3 id="4-接口、抽象类及它们的联系与区别"><a href="#4-接口、抽象类及它们的联系与区别" class="headerlink" title="4. 接口、抽象类及它们的联系与区别"></a>4. 接口、抽象类及它们的联系与区别</h3><ul>
<li><p>抽象类</p>
<ul>
<li>不能被实例化；</li>
<li>抽象方法必须由子类重写，若未被子类重写，则子类也是抽象类；</li>
<li>只要包含一个抽象方法就是抽象类；</li>
<li>抽象类中可以包含具体方法，也可以不包含抽象方法；</li>
<li>子类中的抽象方法不能与父类中同名；</li>
<li><code>abstract</code>和<code>final</code>不能并列修饰同一个类；</li>
<li><code>abstract</code>不能与<code>private</code>、<code>static</code>、<code>final</code>、<code>native</code>并列修饰同一个方法。</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li>一个类可以实现多个接口（实现多继承）；</li>
<li>接口中的常量和方法必须是<code>public</code>的；</li>
<li>在接口中只有方法的声明，没有方法体；</li>
<li>接口中所有方法都必须是抽象的，可以在接口中定义数据成员，但必须是常量；</li>
<li>接口中没有构造方法，也不能实例化出接口的对象；</li>
<li>接口中的方法需要由实现类实现，若实现类不去实现接口中所有的方法，则该类需被定义为抽象类；</li>
<li>接口中不能包含静态方法。</li>
</ul>
</li>
<li><p>联系</p>
<ul>
<li>都不能被实例化；</li>
<li>都可以包含抽象方法。</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li>一个子类只能继承一个抽象类，但可以实现多个接口；</li>
<li>抽象类可以有构造方法，但接口不能；</li>
<li>抽象类可以有普通成员变量，但接口不能；</li>
<li>抽象类和接口都可以有静态成员变量，抽象类中静态成员变量可以是任意访问类型，接口只能为<code>public static final</code>；</li>
<li>抽象类可以没有抽象方法，抽象类可以有普通方法，Java8之前，接口中的方法都为抽象方法，Java8之后，接口中可以有默认方法；</li>
<li>抽象类可以有静态方法，接口不能；</li>
<li>抽象类中方法可以被<code>public</code>或<code>protected</code>修饰，接口中只能由<code>public</code>修饰，Java9接口可以定义私有方法，但不能是抽象的。</li>
</ul>
</li>
</ul>
<h3 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5. 析构函数"></a>5. 析构函数</h3><p>与<strong>构造函数</strong>相反，析构函数用于在对象结束其生命周期时，系统自动调用进行完成“清理善后”工作（如建立对象时使用<code>new</code>开辟了一片内存空间，退出前应在析构函数中使用<code>delete</code>释放）。</p>
<h3 id="6-JDK中常用的包与功能"><a href="#6-JDK中常用的包与功能" class="headerlink" title="6. JDK中常用的包与功能"></a>6. JDK中常用的包与功能</h3><ul>
<li>java.lang：提供使用Java编程语言进行程序设计的基础类；</li>
<li>java.util：提供各种实用功能类，如Collection框架、遗留的Collection类、事件模型、日期和时间、国际化、字符串标记生成器、随机数生成器、位数组等；</li>
<li>java.awt：抽象窗口工具包，用于编写GUI程序；</li>
<li>java.swing：轻量级窗口工具包，现最广泛使用的GUI程序设计包；</li>
<li>java.io：提供系统的输入输出类和接口，只要包括输入流类<code>InputStream</code>和输出流类<code>OutputStream</code>就可以实现文件的输入输出、管道的数据传输以及网络数据传输的功能；</li>
<li>java.net：提供实现网络应用程序的类，包括用于实现Socket通信的<code>Socket</code>类以及便于处理URL的类等；</li>
<li>java.sql：提供使用Java编程语言访问并处理存储在数据源（通常是一个关系数据库）中的数据的 API。</li>
</ul>
<h3 id="7-super和this关键字"><a href="#7-super和this关键字" class="headerlink" title="7. super和this关键字"></a>7. <code>super</code>和<code>this</code>关键字</h3><ul>
<li><code>this</code>表示当前对象，即当前类对象，<code>super</code>表示当前类的父类对象；</li>
<li><code>this()</code>和<code>super()</code>需放在构造函数第一行；</li>
<li>都是对象，所以不能在static环境中使用；</li>
<li><code>this()</code>和<code>super()</code>不能在同一个构造函数内使用。</li>
</ul>
<h3 id="8-Object类的基本方法"><a href="#8-Object类的基本方法" class="headerlink" title="8. Object类的基本方法"></a>8. <code>Object</code>类的基本方法</h3><ul>
<li><code>clone()</code>：实现对对象的浅复制，需实现<code>Cloneable</code>接口才可调用该方法，否则抛出<code>CloneNotSupportedException</code>。</li>
<li><code>getClass()</code>：<code>final</code>方法，获得运行时类型。</li>
<li><code>toString()</code>：返回对象的字符串表示。</li>
<li><code>finalize()</code>：用于资源释放，无法确定该方法何时被调用。</li>
<li><code>equals()</code>：注意与<code>==</code>的区别（<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=128-%e5%92%8cequals%e7%9a%84%e5%8c%ba%e5%88%ab" target="_blank" rel="noopener">equals()与==的区别</a>）。</li>
<li><code>hashCode()</code>：用于哈希查找（<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=129-hashcode%e4%b8%8e-equals" target="_blank" rel="noopener">hashCode()与equals()的区别</a>）。</li>
<li><code>wait()</code>：使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，即具有该对象的锁。<code>wait()</code>一直等待直到获得锁或者被中断。<code>wait(long timeout)</code>设定一个超时间隔，若超时内未获得锁就返回。调用该方法后当前线程进入睡眠状态，直到发生下列事件：<ul>
<li>其他线程调用了该对象的<code>notify()</code>；</li>
<li>其他线程调用了该对象的<code>notifyAll()</code>；</li>
<li>其他线程调用<code>interrupt()</code>中断该线程，此时抛出<code>InterruptedException</code>异常；</li>
<li>超时。</li>
</ul>
</li>
<li><code>notify()</code>：唤醒在该对象上等待的某个线程。</li>
<li><code>notifyAll()</code>：唤醒在该对象上等待的所有线程。</li>
</ul>
<h3 id="9-final关键字"><a href="#9-final关键字" class="headerlink" title="9. final关键字"></a>9. <code>final</code>关键字</h3><ul>
<li>用于修饰类、方法、属性，但不可修饰抽象类，因为抽象类一般需要被继承，<code>final</code>修饰的类无法被继承；</li>
<li>修饰的方法不能被重写（override）；</li>
<li>修饰的属性会变为常量，无法被再赋值。</li>
</ul>
<h3 id="10-J2EE常见名词"><a href="#10-J2EE常见名词" class="headerlink" title="10. J2EE常见名词"></a>10. J2EE常见名词</h3><ul>
<li>EJB：Enterprise Java Bean；</li>
<li>JNDI：Java Naming &amp; Directory Interface，Java命名目录服务；</li>
<li>JMS：Java Message Service，Java消息服务；</li>
<li>JTA：Java Transaction API，Java事务服务；</li>
<li>JAF：Java Action Framework，Java安全认证框架。</li>
</ul>
<h3 id="11-加载驱动的三种方式"><a href="#11-加载驱动的三种方式" class="headerlink" title="11. 加载驱动的三种方式"></a>11. 加载驱动的三种方式</h3><ul>
<li><code>Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;)</code>；</li>
<li><code>DriverManager.registerDriver(new com.mysql.jdbc.Driver())</code>;</li>
<li><code>System.setProperty(&quot;jdbc.drivers&quot;, &quot;com.mysql.jdbc.Driver&quot;)</code>。</li>
</ul>
<h3 id="12-静态方法、静态变量、静态代码块"><a href="#12-静态方法、静态变量、静态代码块" class="headerlink" title="12. 静态方法、静态变量、静态代码块"></a>12. 静态方法、静态变量、静态代码块</h3><ul>
<li><strong>静态方法</strong>不能引用非静态方法和非静态属性，因为静态方法不需要经过实例化就可以使用；</li>
<li>静态方法中没有<code>this</code>指针；</li>
<li>静态方法可以被重载；</li>
<li>静态方法在装载class时首先完成，比构造方法早，此时非静态方法还没有完成初始化，因此无法被调用。</li>
<li><strong>静态代码块</strong>优先于主方法，且只执行一次。</li>
<li>只有类才存在<strong>静态变量</strong>，非静态方法可以调用静态变量，但不能在方法内定义静态变量。</li>
</ul>
<h3 id="13-Java表达式转型规则"><a href="#13-Java表达式转型规则" class="headerlink" title="13. Java表达式转型规则"></a>13. Java表达式转型规则</h3><p>由低到高转换：<code>byte</code> -&gt; <code>short</code>(<code>char</code>) -&gt; <code>int</code> -&gt; <code>long</code> -&gt; <code>float</code> -&gt; <code>double</code></p>
<h3 id="14-基本数据类型和引用数据类型"><a href="#14-基本数据类型和引用数据类型" class="headerlink" title="14. 基本数据类型和引用数据类型"></a>14. 基本数据类型和引用数据类型</h3><p>基本类型（原生类）只能保存一些常量数据；而引用类型除了可以保存数据，还可以提供操作这些数据的功能。为了操作基本数据类型，Java对它们进行了封装，将8中基本数据类型包装为包装类。</p>
<ul>
<li>引用类型包括类、接口、数组和特殊的null类型；</li>
<li>引用数据类型的变量名指向存储数据对象的内存地址，即变量名指向hash值。</li>
</ul>
<h3 id="15-Java变量初始值问题"><a href="#15-Java变量初始值问题" class="headerlink" title="15. Java变量初始值问题"></a>15. Java变量初始值问题</h3><p>类的成员变量有初始值，局部变量没有初始值，<code>final</code>修饰的变量一定要有初始值。</p>
<h3 id="16-Java的四种引用"><a href="#16-Java的四种引用" class="headerlink" title="16. Java的四种引用"></a>16. Java的四种引用</h3><ul>
<li>强引用：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。</li>
<li>软引用：内存不足回收。可以用来做缓存。</li>
<li>弱引用：无论内存是否充足，都会回收被弱引用关联的对象，弱引用能用来在回调函数中防止内存泄露。因为回调函数往往是匿名内部类，隐式保存有对外部类的引用，所以如果回调函数是在另一个线程里面被回调，而这时如果需要回收外部类，那么就会内存泄露，因为匿名内部类保存有对外部类的强引用。</li>
<li>虚引用：它并不影响对象的生命周期。在Java中用<code>java.lang.ref.PhantomReference</code>类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</li>
</ul>
<h3 id="17-Java序列化"><a href="#17-Java序列化" class="headerlink" title="17. Java序列化"></a>17. Java序列化</h3><ul>
<li>序列化：把Java对象转换成字节序列；</li>
<li>反序列化：把字节序列转换成Java对象。</li>
<li>序列化的作用：<ul>
<li>（1）实现数据持久化，通过序列化可以把数据永久存储在磁盘中；</li>
<li>（2）利用序列化实现远程通信，即在网络上传送对象的字节序列。</li>
</ul>
</li>
<li>注意事项：<ul>
<li><code>transient</code>修饰的变量在序列化之后对应的值没了；</li>
<li>不能序列化<code>static</code>变量，静态变量属于类，保存的是类的状态；</li>
<li>需要加上序列化ID。</li>
</ul>
</li>
</ul>
<h3 id="18-类型转换"><a href="#18-类型转换" class="headerlink" title="18. 类型转换"></a>18. 类型转换</h3><ul>
<li>自动类型转换：目标类型大于原类型，如<code>int</code>可以直接赋值给<code>double</code>型。</li>
<li>强制类型转换：目标类型小于原类型，将对于的小数位截断。</li>
<li>类型提升：当一个Java算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将发生自动提升：<ul>
<li>所有<code>byte</code>型、<code>short</code>型和<code>char</code>型将被提升到int型；</li>
<li>整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>, b2 = <span class="number">4</span>, b3;</span><br><span class="line">b3 = (b1 + b2); <span class="comment">// 编译不通过，b1+b2被自动提升为int型，b3为byte型，若要赋值需要进行强转。</span></span><br></pre></td></tr></table></figure>

<h3 id="19-多态"><a href="#19-多态" class="headerlink" title="19. 多态"></a>19. 多态</h3><p>（1）多态的作用</p>
<ul>
<li>一个接口，多种实现，通过抽象化来提高程序的扩展性。</li>
</ul>
<p>（2）多态的条件</p>
<ul>
<li>有继承关系；</li>
<li>子类要重写父类的方法；</li>
<li>父类引用指向子类。</li>
</ul>
<p>（3）多态的注意事项</p>
<ul>
<li>多态后不能使用子类特有的属性和方法；</li>
<li>成员变量和静态方法使用父类的；</li>
<li>子类重写的普通方法使用子类的。</li>
</ul>
<p>（4）基于JVM解释多态</p>
<p>方法调用是依照方法的符号引用得到具体内存引用的过程。调用类的方法（静态方法）在类加载时就直接转化为具体内存引用，为静态绑定；调用对象的方法则是动态绑定，最后得到真正的方法引用，完成调用。</p>
<h3 id="20-数组"><a href="#20-数组" class="headerlink" title="20. 数组"></a>20. 数组</h3><ul>
<li>数组是引用类型，不属于原生类，可以看成是一种对象，一旦指定了大小就无法改变。</li>
<li>数组的初始化：<ul>
<li>左边的名称和括号顺序可以颠倒（如<code>int[] a</code>和<code>int a[]</code>），但右边的第一个括号内一定要有值；</li>
<li>定义数组，左边的括号内不能有值，即数组的大小定义放在右边。</li>
</ul>
</li>
<li>对于多维数组，<code>array.length</code>取的是最外层括号包含的元素个数。</li>
<li>数组的四种拷贝方式效率对比：<code>System.arraycopy</code> &gt; <code>clone</code> &gt; <code>Arrays.copyOf</code> &gt; <code>for</code>。</li>
</ul>
<h3 id="21-Comparable和Comparator的区别"><a href="#21-Comparable和Comparator的区别" class="headerlink" title="21. Comparable和Comparator的区别"></a>21. <code>Comparable</code>和<code>Comparator</code>的区别</h3><ul>
<li><code>Comparable</code>内部比较器：若一个类实现了<code>Comparable</code>接口，则意味着该类支持排序。实现该接口的类的对象的列表或数组可以通过<code>Collections.sort()</code>或<code>Arrays.sort()</code>进行自动排序，一般要重写<code>compareTo()</code>方法；</li>
<li><code>Comparator</code>外部比较器：位于<code>java.util</code>包下，<code>Comparator</code>是比较接口。若需要控制某个类的次序，而该类本身不支持排序（即没有实现<code>Comparable</code>），则可以通过建立一个“该类的比较器”进行排序，这个比较器只需实现<code>Comparator</code>接口，一般要重写<code>compare()</code>方法。</li>
</ul>
<h3 id="22-类的生命周期以及双亲委托机制"><a href="#22-类的生命周期以及双亲委托机制" class="headerlink" title="22. 类的生命周期以及双亲委托机制"></a>22. 类的生命周期以及双亲委托机制</h3><p>生命周期：加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p>
<p><strong>（1）加载</strong></p>
<p>整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。</p>
<p><strong>双亲委托机制</strong>：Java的类加载使用双亲委派模式，即一个类加载器在加载类时，先把这个请求委托给自己的父类加载器去执行，如果父类加载器还存在父类加载器，就继续向上委托，直到顶层的启动类加载器。如果父类加载器能够完成类加载，就成功返回，如果父类加载器无法完成加载，那么子加载器才会尝试自己去加载。</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），JVM的一部分，负责将放置在<code>Jre\lib</code>目录中或者被<code>-Xbootclasspath</code>参数所指定路径中的，并且是虚拟机能识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接使用。</li>
<li>扩展类加载器（Extension ClassLoader），这个类加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>Jre\lib\ext</code>目录中或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader），负责加载<code>ClassPath</code>所有jar或目录，开发者可以直接使用这个类加载器。</li>
<li>自定义加载器</li>
</ul>
<p><strong>（2）验证</strong></p>
<p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求。</p>
<p><strong>（3）准备</strong></p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p>
<ul>
<li>这里内存分配只是类变量（<code>static</code>修饰的），而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中。</li>
<li>为类变量赋值为0值（0、0L、null、false等）。</li>
<li>例如<code>public static int value = 3;</code>，准备阶段会将<code>value</code>赋值为0，直到初始化阶段才将其赋值为3；若被<code>final</code>修饰，则直接赋值为3。</li>
</ul>
<p><strong>（4）解析</strong></p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p><strong>（5）初始化</strong></p>
<p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p>
<p><strong>（6）使用</strong></p>
<p>使用该类所提供的功能，其中包括主动引用和被动引用。</p>
<ul>
<li>主动引用<ul>
<li>通过<code>new</code>关键字实例化对象，读取或设置类的静态变量，调用类的静态方法。</li>
<li>通过反射方式执行上述三种行为。</li>
<li>初始化子类时会触发父类的初始化。</li>
<li>作为程序入口直接运行时（直接调用main方法）。</li>
</ul>
</li>
<li>被动引用<ul>
<li>引用父类的非<code>final</code>静态变量，只会引起父类初始化，不会引起子类初始化。</li>
<li>引用父类的<code>final</code>静态变量，父类子类都不会初始化。</li>
<li>定义类数组不会引起类的初始化。</li>
<li>引用类的常量不会引起类的初始化。</li>
</ul>
</li>
</ul>
<p><strong>（7）卸载</strong></p>
<p>在使用完类后，若满足以下条件，就会被卸载。</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li>
<li>加载该类的ClassLoader已经被回收；</li>
<li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>若上述三个条件全部满足，JVM就会在方法区垃圾回收的时候对类进行卸载，即在方法区中清空类信息，结束Java类的生命周期。</p>
<h3 id="23-动态绑定和静态绑定"><a href="#23-动态绑定和静态绑定" class="headerlink" title="23. 动态绑定和静态绑定"></a>23. 动态绑定和静态绑定</h3><ul>
<li><strong>绑定</strong>的概念：一个方法的调用与所在的类（方法的主体）关联起来。</li>
<li><strong>静态绑定</strong>：在编译过程中就知道该方法是哪个类中的方法，只有<code>final</code>、<code>static</code>（重写<code>static</code>方法使用多态，调用的仍然是父类的<code>static</code>方法）、<code>private</code>和构造方法使用静态绑定。</li>
<li><strong>动态绑定</strong>：在运行时绑定。<strong>原理</strong>：父类不是接口，当子类和父类加载到虚拟机时，方法区就有了类的信息，方法区中有方法表，如果子类重写父类的方法，那么在各自方法表里方法的偏移量是一样的，当我们调用时，<ul>
<li>先找到方法调用的符号引用，</li>
<li>查看父类偏移量，</li>
<li>找到具体子类，</li>
<li>根据父类偏移量查看子类方法表有没有重写。</li>
</ul>
</li>
</ul>
<p>如果父类是接口的话，无法根据偏移量来确定，则采用搜索方法表的形式，效率要低些。</p>
<h3 id="24-HashMap"><a href="#24-HashMap" class="headerlink" title="24. HashMap"></a>24. HashMap</h3><p>（1）基本结构</p>
<ul>
<li><p>构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">HashMap() <span class="comment">// 默认大小为16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定容量大小</span></span><br><span class="line">HashMap(<span class="keyword">int</span> capacity) <span class="comment">// capacity必须是2的次幂，从而减少碰撞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定容量大小和加载因子</span></span><br><span class="line">HashMap(<span class="keyword">int</span> capacity, <span class="keyword">float</span> loadFactor) <span class="comment">// loadFactor默认值是0.75</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含 子Map 的构造函数</span></span><br><span class="line">HashMap(Map&lt;? extends K, ? extends V&gt; map)</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本结构</p>
<ul>
<li>jdk1.7：数组+链表（头插）</li>
<li>jdk1.8：数组+链表（尾插）/红黑树（链表长度到8时，将链表转换成红黑树来处理）</li>
</ul>
</li>
</ul>
<p>（2）存取元素</p>
<ul>
<li>存元素：HashMap会对<code>key</code>值为null的进行特殊处理，总是放到<code>table[0]</code>位置。<code>put()</code>过程是先计算哈希值然后通过哈希值与<code>table.length</code>取模计算index值，然后将key放到<code>table[index]</code>位置，当<code>table[index]</code>已存在其它元素时，会在<code>table[index]</code>位置生成一个链表，将新添加的元素放在<code>table[index]</code>（头插），原来的元素连接到<code>Entry.next</code>，这样以链表形式解决哈希冲突问题，当元素数量达到临界值时，则进行扩容，使table数组长度变为原来的两倍。jdk1.8版本中，链表改为尾插，且当长度超过8时转换为红黑树。</li>
<li>取元素：同样当<code>key</code>为null时会进行特殊处理，在<code>table[0]</code>的链表上查找key为null的元素。<code>get()</code>的过程是先计算哈希值然后通过哈希值与<code>table.length</code>取模计算index值，然后从<code>table[index]</code>上的链表或红黑树找到key，然后返回。</li>
</ul>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        
        <li>
            <a target="_blank" href="http://weibo.com/3055837443">
                            <span class="fa-stack fa-lg">
                                  <i class="iconfont icon-weibo"></i>
                            </span>
            </a>
        </li>
        

        

        
        <li>
            <a target="_blank"  href="https://github.com/BlackedSide">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="http://www.fannyuan.xyz" target="_blank" rel="noopener">BlackSide&#39;s Page</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
