[{"title":"Java基础汇总（持续更新……）","url":"/2020/06/22/Java基础汇总（持续更新……）/","content":"\n>把所有的基础内容整理成条目以便于回顾复习！\n\n### 1. Java重载、重写与隐藏\n- 重载（overload）：类中多态性的表现。\n    - 根据方法参数列表中的参数类型或参数个数；\n    - 不可以基于方法的返回值类型。\n- 重写（override）：\n    - “两小”：子类方法的返回值类型、抛出的异常均小于父类方法的；\n    - “两同”：子类方法的方法名和参数列表均与父类方法的相同；\n    - “一大”：子类方法的访问权限应大于父类方法的。\n- 隐藏：针对父类的成员变量或静态方法。\n    - 子类声明了与父类相同的变量时，父类的同名变量被隐藏；\n    - 子类声明了与父类同名的静态方法、且方法的参数列表与返回值类型均与父类方法相同时，父类的同名静态方法被隐藏。\n\n### 2. 构造方法\n- 与类名相同；\n- 没有返回类型，也不能为`void`；\n- 完成对象的初始化工作，将定义对象时的参数传递给对象的域；\n- 一个类可以定义多个构造方法，若不定义，则会自动生成一个无参数的构造方法，且方法内不执行任何代码；\n- 可以根据参数列表中参数的类型、个数、顺序对构造方法重载；\n- 不能被`static`、`final`、`synchronized`、`abstract`、`native`修饰，但可以被`private`、`protected`、`public`修饰；\n- 不能被继承，只能被显式或隐式的调用；\n- 若父类没有无参的构造方法，则子类需在自己的构造方法中显式地调用父类的构造方法；\n- 构造方法每次都是构造新的对象，不存在多个线程同时读写同一个对象中属性的问题，所以不需要同步。\n\n### 3. 访问修饰符\n- `public`：当前类、子类、包内、其他包；\n- `protected`：当前类、子类、包内；\n- `default`：当前类、包内；\n- `private`：当前类。\n- `private`的属性和方法可以被子类继承，但不能被子类调用。\n\n### 4. 接口、抽象类及它们的联系与区别\n- 抽象类\n    - 不能被实例化；\n    - 抽象方法必须由子类重写，若未被子类重写，则子类也是抽象类；\n    - 只要包含一个抽象方法就是抽象类；\n    - 抽象类中可以包含具体方法，也可以不包含抽象方法；\n    - 子类中的抽象方法不能与父类中同名；\n    - `abstract`和`final`不能并列修饰同一个类；\n    - `abstract`不能与`private`、`static`、`final`、`native`并列修饰同一个方法。\n\n- 接口\n    - 一个类可以实现多个接口（实现多继承）；\n    - 接口中的常量和方法必须是`public`的；\n    - 在接口中只有方法的声明，没有方法体；\n    - 接口中所有方法都必须是抽象的，可以在接口中定义数据成员，但必须是常量；\n    - 接口中没有构造方法，也不能实例化出接口的对象；\n    - 接口中的方法需要由实现类实现，若实现类不去实现接口中所有的方法，则该类需被定义为抽象类；\n    - 接口中不能包含静态方法。\n\n- 联系\n    - 都不能被实例化；\n    - 都可以包含抽象方法。\n\n- 区别\n    - 一个子类只能继承一个抽象类，但可以实现多个接口；\n    - 抽象类可以有构造方法，但接口不能；\n    - 抽象类可以有普通成员变量，但接口不能；\n    - 抽象类和接口都可以有静态成员变量，抽象类中静态成员变量可以是任意访问类型，接口只能为`public static final`；\n    - 抽象类可以没有抽象方法，抽象类可以有普通方法，Java8之前，接口中的方法都为抽象方法，Java8之后，接口中可以有默认方法；\n    - 抽象类可以有静态方法，接口不能；\n    - 抽象类中方法可以被`public`或`protected`修饰，接口中只能由`public`修饰，Java9接口可以定义私有方法，但不能是抽象的。\n\n### 5. 析构函数\n与**构造函数**相反，析构函数用于在对象结束其生命周期时，系统自动调用进行完成“清理善后”工作（如建立对象时使用`new`开辟了一片内存空间，退出前应在析构函数中使用`delete`释放）。\n\n### 6. JDK中常用的包与功能\n- java.lang：提供使用Java编程语言进行程序设计的基础类；\n- java.util：提供各种实用功能类，如Collection框架、遗留的Collection类、事件模型、日期和时间、国际化、字符串标记生成器、随机数生成器、位数组等；\n- java.awt：抽象窗口工具包，用于编写GUI程序；\n- java.swing：轻量级窗口工具包，现最广泛使用的GUI程序设计包；\n- java.io：提供系统的输入输出类和接口，只要包括输入流类`InputStream`和输出流类`OutputStream`就可以实现文件的输入输出、管道的数据传输以及网络数据传输的功能；\n- java.net：提供实现网络应用程序的类，包括用于实现Socket通信的`Socket`类以及便于处理URL的类等；\n- java.sql：提供使用Java编程语言访问并处理存储在数据源（通常是一个关系数据库）中的数据的 API。\n\n### 7. `super`和`this`关键字\n- `this`表示当前对象，即当前类对象，`super`表示当前类的父类对象；\n- `this()`和`super()`需放在构造函数第一行；\n- 都是对象，所以不能在static环境中使用；\n- `this()`和`super()`不能在同一个构造函数内使用。\n\n### 8. `Object`类的基本方法\n- `clone()`：实现对对象的浅复制，需实现`Cloneable`接口才可调用该方法，否则抛出`CloneNotSupportedException`。\n- `getClass()`：`final`方法，获得运行时类型。\n- `toString()`：返回对象的字符串表示。\n- `finalize()`：用于资源释放，无法确定该方法何时被调用。\n- `equals()`：注意与`==`的区别（[equals()与==的区别](https://snailclimb.gitee.io/javaguide/#/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=128-%e5%92%8cequals%e7%9a%84%e5%8c%ba%e5%88%ab)）。\n- `hashCode()`：用于哈希查找（[hashCode()与equals()的区别](https://snailclimb.gitee.io/javaguide/#/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=129-hashcode%e4%b8%8e-equals)）。\n- `wait()`：使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，即具有该对象的锁。`wait()`一直等待直到获得锁或者被中断。`wait(long timeout)`设定一个超时间隔，若超时内未获得锁就返回。调用该方法后当前线程进入睡眠状态，直到发生下列事件：\n    - 其他线程调用了该对象的`notify()`；\n    - 其他线程调用了该对象的`notifyAll()`；\n    - 其他线程调用`interrupt()`中断该线程，此时抛出`InterruptedException`异常；\n    - 超时。\n- `notify()`：唤醒在该对象上等待的某个线程。\n- `notifyAll()`：唤醒在该对象上等待的所有线程。\n\n### 9. `final`关键字\n- 用于修饰类、方法、属性，但不可修饰抽象类，因为抽象类一般需要被继承，`final`修饰的类无法被继承；\n- 修饰的方法不能被重写（override）；\n- 修饰的属性会变为常量，无法被再赋值。\n\n### 10. J2EE常见名词\n- EJB：Enterprise Java Bean；\n- JNDI：Java Naming & Directory Interface，Java命名目录服务；\n- JMS：Java Message Service，Java消息服务；\n- JTA：Java Transaction API，Java事务服务；\n- JAF：Java Action Framework，Java安全认证框架。\n\n### 11. 加载驱动的三种方式\n- `Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\")`；\n- `DriverManager.registerDriver(new com.mysql.jdbc.Driver())`;\n- `System.setProperty(\"jdbc.drivers\", \"com.mysql.jdbc.Driver\")`。\n\n### 12. 静态方法、静态变量、静态代码块\n- **静态方法**不能引用非静态方法和非静态属性，因为静态方法不需要经过实例化就可以使用；\n- 静态方法中没有`this`指针；\n- 静态方法可以被重载；\n- 静态方法在装载class时首先完成，比构造方法早，此时非静态方法还没有完成初始化，因此无法被调用。\n- **静态代码块**优先于主方法，且只执行一次。\n- 只有类才存在**静态变量**，非静态方法可以调用静态变量，但不能在方法内定义静态变量。\n\n### 13. Java表达式转型规则\n由低到高转换：`byte` -> `short`(`char`) -> `int` -> `long` -> `float` -> `double`\n\n### 14. 基本数据类型和引用数据类型\n基本类型（原生类）只能保存一些常量数据；而引用类型除了可以保存数据，还可以提供操作这些数据的功能。为了操作基本数据类型，Java对它们进行了封装，将8中基本数据类型包装为包装类。\n- 引用类型包括类、接口、数组和特殊的null类型；\n- 引用数据类型的变量名指向存储数据对象的内存地址，即变量名指向hash值。\n\n### 15. Java变量初始值问题\n类的成员变量有初始值，局部变量没有初始值，`final`修饰的变量一定要有初始值。\n\n### 16. Java的四种引用\n- 强引用：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。\n- 软引用：内存不足回收。可以用来做缓存。\n- 弱引用：无论内存是否充足，都会回收被弱引用关联的对象，弱引用能用来在回调函数中防止内存泄露。因为回调函数往往是匿名内部类，隐式保存有对外部类的引用，所以如果回调函数是在另一个线程里面被回调，而这时如果需要回收外部类，那么就会内存泄露，因为匿名内部类保存有对外部类的强引用。\n- 虚引用：它并不影响对象的生命周期。在Java中用`java.lang.ref.PhantomReference`类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。\n\n### 17. Java序列化\n- 序列化：把Java对象转换成字节序列；\n- 反序列化：把字节序列转换成Java对象。\n- 序列化的作用：\n    - （1）实现数据持久化，通过序列化可以把数据永久存储在磁盘中；\n    - （2）利用序列化实现远程通信，即在网络上传送对象的字节序列。\n- 注意事项：\n    - `transient`修饰的变量在序列化之后对应的值没了；\n    - 不能序列化`static`变量，静态变量属于类，保存的是类的状态；\n    - 需要加上序列化ID。\n\n### 18. 类型转换\n- 自动类型转换：目标类型大于原类型，如`int`可以直接赋值给`double`型。\n- 强制类型转换：目标类型小于原类型，将对于的小数位截断。\n- 类型提升：当一个Java算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将发生自动提升：\n    - 所有`byte`型、`short`型和`char`型将被提升到int型；\n    - 整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型。\n\n```java\nbyte b1 = 3, b2 = 4, b3;\nb3 = (b1 + b2); // 编译不通过，b1+b2被自动提升为int型，b3为byte型，若要赋值需要进行强转。\n```\n\n### 19. 多态\n（1）多态的作用\n- 一个接口，多种实现，通过抽象化来提高程序的扩展性。\n\n（2）多态的条件\n- 有继承关系；\n- 子类要重写父类的方法；\n- 父类引用指向子类。\n\n（3）多态的注意事项\n- 多态后不能使用子类特有的属性和方法；\n- 成员变量和静态方法使用父类的；\n- 子类重写的普通方法使用子类的。\n\n（4）基于JVM解释多态\n\n方法调用是依照方法的符号引用得到具体内存引用的过程。调用类的方法（静态方法）在类加载时就直接转化为具体内存引用，为静态绑定；调用对象的方法则是动态绑定，最后得到真正的方法引用，完成调用。\n\n### 20. 数组\n- 数组是引用类型，不属于原生类，可以看成是一种对象，一旦指定了大小就无法改变。\n- 数组的初始化：\n    - 左边的名称和括号顺序可以颠倒（如`int[] a`和`int a[]`），但右边的第一个括号内一定要有值；\n    - 定义数组，左边的括号内不能有值，即数组的大小定义放在右边。\n- 对于多维数组，`array.length`取的是最外层括号包含的元素个数。\n- 数组的四种拷贝方式效率对比：`System.arraycopy` > `clone` > `Arrays.copyOf` > `for`。\n\n### 21. `Comparable`和`Comparator`的区别\n- `Comparable`内部比较器：若一个类实现了`Comparable`接口，则意味着该类支持排序。实现该接口的类的对象的列表或数组可以通过`Collections.sort()`或`Arrays.sort()`进行自动排序，一般要重写`compareTo()`方法；\n- `Comparator`外部比较器：位于`java.util`包下，`Comparator`是比较接口。若需要控制某个类的次序，而该类本身不支持排序（即没有实现`Comparable`），则可以通过建立一个“该类的比较器”进行排序，这个比较器只需实现`Comparator`接口，一般要重写`compare()`方法。\n\n### 22. 类的生命周期以及双亲委托机制\n生命周期：加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载\n\n**（1）加载**\n\n整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。\n\n**双亲委托机制**：Java的类加载使用双亲委派模式，即一个类加载器在加载类时，先把这个请求委托给自己的父类加载器去执行，如果父类加载器还存在父类加载器，就继续向上委托，直到顶层的启动类加载器。如果父类加载器能够完成类加载，就成功返回，如果父类加载器无法完成加载，那么子加载器才会尝试自己去加载。\n\n- 启动类加载器（Bootstrap ClassLoader），JVM的一部分，负责将放置在`Jre\\lib`目录中或者被`-Xbootclasspath`参数所指定路径中的，并且是虚拟机能识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接使用。\n- 扩展类加载器（Extension ClassLoader），这个类加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载`Jre\\lib\\ext`目录中或者被`java.ext.dirs`系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。\n- 应用程序类加载器（Application ClassLoader），负责加载`ClassPath`所有jar或目录，开发者可以直接使用这个类加载器。\n- 自定义加载器\n\n**（2）验证**\n\n验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求。\n\n**（3）准备**\n\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。\n- 这里内存分配只是类变量（`static`修饰的），而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中。\n- 为类变量赋值为0值（0、0L、null、false等）。\n- 例如`public static int value = 3;`，准备阶段会将`value`赋值为0，直到初始化阶段才将其赋值为3；若被`final`修饰，则直接赋值为3。\n\n**（4）解析**\n\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。\n\n**（5）初始化**\n\n初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。\n\n**（6）使用**\n\n使用该类所提供的功能，其中包括主动引用和被动引用。\n- 主动引用\n    - 通过`new`关键字实例化对象，读取或设置类的静态变量，调用类的静态方法。\n    - 通过反射方式执行上述三种行为。\n    - 初始化子类时会触发父类的初始化。\n    - 作为程序入口直接运行时（直接调用main方法）。\n- 被动引用\n    - 引用父类的非`final`静态变量，只会引起父类初始化，不会引起子类初始化。\n    - 引用父类的`final`静态变量，父类子类都不会初始化。\n    - 定义类数组不会引起类的初始化。\n    - 引用类的常量不会引起类的初始化。\n\n**（7）卸载**\n\n在使用完类后，若满足以下条件，就会被卸载。\n- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；\n- 加载该类的ClassLoader已经被回收；\n- 该类对应的`java.lang.Class`对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n若上述三个条件全部满足，JVM就会在方法区垃圾回收的时候对类进行卸载，即在方法区中清空类信息，结束Java类的生命周期。\n\n### 23. 动态绑定和静态绑定\n- **绑定**的概念：一个方法的调用与所在的类（方法的主体）关联起来。\n- **静态绑定**：在编译过程中就知道该方法是哪个类中的方法，只有`final`、`static`（重写`static`方法使用多态，调用的仍然是父类的`static`方法）、`private`和构造方法使用静态绑定。\n- **动态绑定**：在运行时绑定。**原理**：父类不是接口，当子类和父类加载到虚拟机时，方法区就有了类的信息，方法区中有方法表，如果子类重写父类的方法，那么在各自方法表里方法的偏移量是一样的，当我们调用时，\n    - 先找到方法调用的符号引用，\n    - 查看父类偏移量，\n    - 找到具体子类，\n    - 根据父类偏移量查看子类方法表有没有重写。\n\n如果父类是接口的话，无法根据偏移量来确定，则采用搜索方法表的形式，效率要低些。\n\n### 24. HashMap\n（1）基本结构\n- 构造函数\n```java\n// 默认构造函数\nHashMap() // 默认大小为16\n\n// 指定容量大小\nHashMap(int capacity) // capacity必须是2的次幂，从而减少碰撞\n\n// 指定容量大小和加载因子\nHashMap(int capacity, float loadFactor) // loadFactor默认值是0.75\n\n// 包含 子Map 的构造函数\nHashMap(Map<? extends K, ? extends V> map)\n```\n\n- 基本结构\n    - jdk1.7：数组+链表（头插）\n    - jdk1.8：数组+链表（尾插）/红黑树（链表长度到8时，将链表转换成红黑树来处理）\n\n（2）存取元素\n- 存元素：HashMap会对`key`值为null的进行特殊处理，总是放到`table[0]`位置。`put()`过程是先计算哈希值然后通过哈希值与`table.length`取模计算index值，然后将key放到`table[index]`位置，当`table[index]`已存在其它元素时，会在`table[index]`位置生成一个链表，将新添加的元素放在`table[index]`（头插），原来的元素连接到`Entry.next`，这样以链表形式解决哈希冲突问题，当元素数量达到临界值时，则进行扩容，使table数组长度变为原来的两倍。jdk1.8版本中，链表改为尾插，且当长度超过8时转换为红黑树。\n- 取元素：同样当`key`为null时会进行特殊处理，在`table[0]`的链表上查找key为null的元素。`get()`的过程是先计算哈希值然后通过哈希值与`table.length`取模计算index值，然后从`table[index]`上的链表或红黑树找到key，然后返回。","tags":["Java"]},{"title":"Ubuntu16环境下部署Cbench测试工具","url":"/2020/05/26/Ubuntu16环境下部署Cbench测试工具/","content":"\n>哦，天啊，SDN实验，永远滴痛。\n\n今天折腾SDN的实验，使用SDN的Controller Benchmark测试工具Cbench来测试SDN控制器的性能。众所周知（也许只我一菜逼知道），由于一些文档的缺乏，加上各种工具版本的更迭导致的各工具之间不兼容问题，SDN的实验环境极其难以部署（吧）。今天在Ubuntu16.04LTS环境下搭建了该测试环境，费了不少功夫，不过也算是完成了。\n\n## 实验环境\n- 操作系统：Ubuntu16.04LTS\n- SDN控制器：Floodlight（github master）最新版（https://github.com/floodlight/floodlight）\n- 测试工具：Cbench（https://github.com/mininet/oflops）\n- OpenFlow：1.0（https://github.com/mininet/openflow）\n\n## 搭建步骤\n### 一. 安装Floodlight控制器\n#### 1. 安装jdk8\n\n由于最新版Floodlight控制器依赖Java8版本，所以操作系统中需要配置jdk8环境。\n\n我一开始使用命令行安装的openjdk-1.8，但是导致Floodlight安装过程出现了问题，所以从jdk官网下载了jdk1.8，通过.bashrc配置系统变量，解决了Floodlight安装错误问题。\n\n- 从oracle官网下载jdk1.8-linux-x64版\n```text\n我下载的版本是 jdk-8u251-linux-x64.tar.gz\n```\n- 解压到/opt/java文件夹中（这里其实可以随意，只要后面配对系统环境变量就行）\n```shell\nsudo tar -zxvf jdk-8u251-linux-x64.tar.gz -C /opt/java/\n```\n- 配置环境变量，在`~/.bashrc`中添加下列两行\n```shell\n# cd ~\n# vim .bashrc\n```\n```\nexport JAVA_HOME=/opt/java/jdk1.8.0_251\nexport PATH=${JAVA_HOME}/bin:${PATH}\n```\n- 使`.bashrc`生效\n```shell\nsource ~/.bashrc\n```\n\n#### 2. 安装Floodlight控制器\n- 安装依赖\n```shell\n# sudo apt-get install build-essential ant maven python-dev\n```\n- 进入`~`目录\n- 操作如下\n```shell\n# git clone git://github.com/floodlight/floodlight.git\n# cd floodlight\n# git submodule init\n# git submodule update\n# ant\n\n# sudo mkdir /var/lib/floodlight\n# sudo chmod 777 /var/lib/floodlight\n```\n\n### 二. 安装OpenFlow\n- 进入`~`目录\n- 操作如下\n```shell\n# git clone git://github.com/mininet/openflow.git\n```\n- 这里得到OpenFlow的目录是你用户目录下的`openflow`目录，等会需要用到，直接进入该目录输入`pwd`即可获取完整绝对路径\n\n### 三. 安装Cbench\n- 安装必要的依赖\n```shell\n# sudo apt-get install autoconf automake libtool libpcap-dev\n```\n- 注意这里我没有按照官网上安装`libsnmp-dev`，因为我安装的时候出错了。用如下方法安装：（aptitude可以帮助你安装需要的依赖，或者帮助你选择降级部分依赖来使得能够正确安装与使用）\n```shell\n# sudo apt-get install aptitude\n# sudo aptitude install libsnmp-dev\n```\n- 安装Cbench，在`~`目录下，这里的`/home/funny/openflow`是我之前OpenFlow安装的目录\n```shell\n# git clone git://github.com/mininet/oflops.git\n# cd oflops/\n# sh boot.sh\n# ./configure --with-openflow-src-dir=/home/funny/openflow\n# make\n# sudo make install\n```\n- 如果在`make`过程中出现`libconfig.h: No such file or directory`的错误，则安装`libconfig-dev`\n```shell\n# sudo apt-get install libconfig-dev\n```\n\n至此，Cbench就完整的安装完成了。开始做实验吧（哭脸）~","tags":["SDN"]},{"title":"关于finally子句是否总是一定执行的问题","url":"/2020/05/25/关于finally子句是否总是一定执行的问题/","content":"\n之前在牛客上看到一道面试题，是关于“finally子句是否总是一定会被执行”。在初学Java异常章节的时候，学习到`try-catch-finally`的语句，说明了`finally`子句的用途是用于确保安全的回收资源等，因此`finally`子句总是会被系统执行。而学习到并发章节的时候，找到了一个特例。章节内容见`《Java编程思想》第21章-21.2.8-后台线程`。\n\n如下一段代码：\n```java\nclass ADaemon implements Runnable {\n    @Override\n    public void run() {\n        try {\n            System.out.println(\"Starting ADaemon\");\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            System.out.println(\"Existing via InterruptedException\");\n        } finally {\n            System.out.println(\"This should always run?\");\n        }\n    }\n}\n\npublic class DaemonsDontRunFinally {\n    public static void main(String[] atgs) throws Exception {\n        Thread t = new Thread(new ADaemon());\n        t.setDaemon(true);\n        t.start();\n    }\n}\n\n/* Output:\nStarting ADaemon\n*///:~\n```\n\n由于线程`t`被注册为后台线程，因此当执行该程序后，`finally`子句将不会得到执行，除非注释掉`setDaemon()`的调用。结合书中所述，由于非后台线程`main()`被终止时，后台线程会“**突然**”终止，即JVM会在`main()`退出后立即关闭所有后台进程，而不会有任何被希望出现的确认形式。故在这种情况下，`finally`子句将无法被执行。\n\n在牛客的面试题中，一条回答表示“当在finally子句前调用System.exit(0)”时，`finally`子句就不会被执行。即如上后台线程示例的情况一致，由于在`main()`线程中退出，其退出动作发生在`run()`中的`finally`子句之前，故`finally`子句将不会被执行。\n\n关于这个问题涉及到JVM的运行机制以及线程等问题，在此先留题占坑，等待后续学习到更加清晰的原因时再来补充解释。（2020.5.25）","tags":["Java"]},{"title":"简单说Java中接口和抽象类的区别","url":"/2020/05/10/简单说Java中接口和抽象类的区别/","content":"\n>本文参考自——牛客题库-Java校招面试题汇总\n\n### 从定义上说\n- 接口中所有的方法隐含的都是抽象的；而抽象类则可以同时包含抽象和非抽象的方法。\n- Java中只支持单继承。对于接口来说，类可以实现多个接口；但只能继承自一个抽象类。\n- 接口中声明的变量（成员属性）都是`final`的；而抽象类可以包含`非final`的变量（成员属性）。\n- 接口中的成员函数（成员方法）默认是`public`的；而抽象类的成员函数（成员方法）可以是`private`、`protected`和`public`。\n- 接口是绝对抽象的，不可以被实例化；抽象类也不可以被实例化。\n- 类可以不实现抽象类和接口中声明的所有方法，但在此情况下，该类必须得声明为抽象类。\n- 基于上一条，抽象类可以在不提供接口方法实现的情况下实现接口。即，普通类实现了一个接口，则必须给出该接口内所有方法的具体实现；而抽象类实现接口，可以不在该抽象类内部给出接口中方法的实现，但若某普通类继承自该抽象类，必须给出该接口中所有方法的具体实现。代码如下：\n```java\ninterface A {\n    void f();\n}\n\nabstract class B implements A {\n    public abstract void g();\n}\n\npublic class C extends B {\n    /**\n    * 这里的f()方法必须被声明为public的，因为接口中的方法签名默认为public\n    */\n    @Override\n    public void f() {\n        ...\n    }\n\n    /**\n    * 这里g()方法的访问权限不能小于原方法签名所声明的权限，如原方法声明为public，这里就不能使用protected等public以下的关键字修饰\n    */\n    @Override\n    public void g() {\n        ...\n    }\n}\n```\n\n### 从设计层面来说\n- 抽象类是对类的抽象，是一种模板设计。\n- 接口是对行为的抽象，是一种行为的规范。","tags":["Java"]},{"title":"Java链表操作中易犯的错误","url":"/2020/05/07/Java链表操作中易犯的错误/","content":"\n今天刷《剑指offer》中的链表操作的题目，在一处曾经经常出错的位置再一次犯了错误，该错误为在一个自定义的链表中，遍历链表节点的过程中，由于错误的判断语句导致的死循环。具体代码如下：\n\n```java\n/**\n* 链表节点的定义\n*/\nclass Node {\n    int val;\n    Node next;\n\n    Node(int val) {\n        this.val = val;\n    }\n}\n\n/**\n* 遍历链表的操作\n*/\npublic class LinkedList {\n    public void iterateNode(Node node) {\n        while (node != null) {\n            System.out.print(node.val + \" \");\n            if (node.next != null) { // 错误发生在此处，由于加入判断下一个节点不为空，才将next指针向后移动，所以当遍历到链表的最后一个节点时，它的下一个节点必为null，于是指针不向后移动，当前节点永不为null，发生死循环\n                node = node.next;\n            }\n        }\n    }\n}\n```\n\n其实如上代码中的遍历中，`if (node.next != null)`不仅是多余的语句，而且也是错误的语句。因为在节点初始化的过程中，`next`成员会被初始化为`null`，故在`while (node != null)`的循环判断中，可以直接判断当前节点是否为空。若遍历到链表中最后一个节点时，它的下一个节点为空节点，可以直接执行`node = node.next`来将指针后移，在下一次`while`判断后不进入循环即可正常运行。修改后的代码如下：\n\n```java\npublic void iterateNode(Node node) {\n    while (node != null) {\n        System.out.print(node.val + \" \");\n        node = node.next;\n    }\n}\n```","tags":["Java","数据结构"]},{"title":"一份代码搞清楚内部类","url":"/2020/02/26/一份代码搞清楚内部类/","content":"\n最近学习神书《Java编程思想》，学习到第10章内部类的内容时，花了很久时间消化。现在基本搞懂了一些基本，用一份代码大致上总结了全章大部分内容。\n\n解释说明全部在代码中用注释标识，以供理解。\n\n```java\npackage com.blackside.chapter_10;\n\ninterface Counter {\n    int next();\n}\n\npublic class TestForInnerClass {\n    private String name = \"OuterClass\";\n    private int testCount;\n\n    private class InnerClass {\n        private String name = \"InnerClass\";\n\n        /**\n         * 当内部类与外围类具有相同名的成员属性时，如何区分？\n         * 内部类中，用this标识符指代内部类自己，用 外围类名.this 指代外围类\n         * @return\n         */\n        // 操作内部类的成员属性\n        public String returnInnerName() {\n            return this.name;\n        }\n\n        // 操作外围类的成员属性\n        public String returnOuterName() {\n            return TestForInnerClass.this.name;\n        }\n    }\n\n    /**\n     * 局部内部类\n     * 可以拥有构造器\n     * 局部内部类对象，对其外围类来说可以拥有多个，即内部类可以复用\n     * @param givenName\n     * @return\n     */\n    public Counter[] getLocalInnerClass(final String givenName) {\n        Counter[] counters = new Counter[2];\n\n        class LocalInnerClass implements Counter {\n            private String name = \"LocalInner\";\n            private int number;\n\n            // 局部内部类的构造器\n            public LocalInnerClass(int number) {\n                /**\n                 * 这里形参不允许被修改，则说明局部内部类的形参需要被定义为final\n                 */\n                this.number = number;\n//                givenName += \"Testing\";\n                System.out.println(\"I am LocalInnerClass \" + this.number + \".\");\n            }\n\n            @Override\n            public int next() {\n                System.out.print(TestForInnerClass.this.name + name + \" \" + givenName + \" \" + this.number + \" output \");\n                return testCount++;\n            }\n        }\n        // 这里，不匿名的局部内部类得到复用，可以创建多个该内部类的对象\n        counters[0] = new LocalInnerClass(1);\n        counters[1] = new LocalInnerClass(2);\n        return counters;\n    }\n\n    /**\n     * 匿名内部类\n     * 无法拥有构造器，但可以使用实例初始化的方式\n     * 匿名内部类对象对于其外围类，只能拥有一个，匿名内部类无法使用多次\n     * @param givenName\n     * @return\n     */\n    public Counter getAnonymousInner(final String givenName) {\n        // 返回的匿名内部类对象一次性返回，且只产生一个对象，无法复用\n        return new Counter() {\n            private String name = \"LocalAnonymousClass\";\n\n            // 匿名内部类无法拥有构造器，这里使用实例初始化的方式\n            {\n                /**\n                 * 这里形参不允许被修改，则说明局部内部类的形参需要被定义为final\n                 */\n//                givenName += \"Testing\";\n                System.out.println(\"I am LocalAnonymousInnerClass.\"); // 匿名内部类无法拥有构造器，可以使用实例初始化的方式\n            }\n\n            @Override\n            public int next() {\n                System.out.print(TestForInnerClass.this.name + \" \" + name + \" \" + givenName + \" output \");\n                return testCount++;\n            }\n        };\n    }\n\n    public InnerClass getInnerClass() {\n        return new InnerClass();\n    }\n\n    public static void main(String[] args) {\n        TestForInnerClass test = new TestForInnerClass();\n\n        InnerClass innerClass = test.getInnerClass();\n        System.out.println(innerClass.returnInnerName());\n        System.out.println(innerClass.returnOuterName());\n\n        Counter[] localInner = test.getLocalInnerClass(\"001\");\n        System.out.println(localInner[0].next());\n        System.out.println(localInner[1].next());\n\n        Counter anonymousInner = test.getAnonymousInner(\"002\");\n        System.out.println(anonymousInner.next());\n    }\n}\n```","tags":["Java"]},{"title":"简单谈匿名内部类用在工厂方法的理解","url":"/2020/02/24/简单谈匿名内部类用在工厂方法的理解/","content":"\n### 简单说内部类\n- 将一个类定义在另一个类的定义内部，就是内部类，而这里的另一个类被称为**外围类**（或外部类）。\n- 内部类对象被外围类（外部类）创建时，会自动拥有一个指向该外围类的引用，还包含外围类对象的信息（闭包）。这意味着，内部类可以直接操作外围类的成员，即是是私有（private）的成员属性与方法，而无需实例出外围类的对象（因为自动拥有）。\n- 由于Java的继承是单继承，而每个内部类都能够独立地继承自一个（接口的）实现，也即，内部类为外围类提供了“可以继承多个具体或抽象的类”的能力。\n- 类的实质是一种新的数据类型，创建私有（private）的内部类即同理创建一个具有新数据结构的私有成员。\n\n### 匿名内部类\n匿名内部类通过一个返回值为基类接口（向上转型）的方法创建出一个没有类名的对象。简单来看：\n\n```java\nclass A {\n    void say() {\n        System.out.println(\"I am A.\");\n    }\n}\n\npublic class B {\n    public A createA() {\n        return new A() {\n            @Override\n            public void say() {\n                System.out.println(\"I am inside B.\");\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        B b = new B();\n        A a = b.createA();\n        a.say();\n    }\n}\n\n/**\n* Output:\n* I am inside B.\n*/\n```\n匿名内部类简化了代码，由于不具有类名，匿名内部类只被使用一次。接下来看看工厂方法中使用匿名内部类以简化代码。\n\n### 工厂方法\n#### 1. 先看不使用匿名内部类实现的工厂方法\n\n```java\ninterface Cycle {\n    void ride();\n}\n\ninterface CycleFactory {\n    Cycle getCycle();\n}\n\nclass Bicycle implements Cycle {\n    @Override\n    public void ride() {\n        System.out.println(\"Bicycle rides.\");\n    }\n}\n\nclass BicycleFactory implements CycleFactory {\n    @Override\n    public Cycle getCycle() {\n        return new Bicycle();\n    }\n}\n\npublic class Factory {\n    public static void cycleConsumer(CycleFactory factory) {\n        Cycle cycle = factory.getCycle();\n        cycle.ride();\n    }\n\n    public static void main(String[] args) {\n        cycleConsumer(new BicycleFactory());\n    }\n}\n```\n\n#### 2. 再看使用了匿名内部类的工厂方法\n\n```java\ninterface Cycle {\n    void ride();\n}\n\ninterface CycleFactory {\n    Cycle getCycle();\n}\n\nclass Bicycle implements Cycle {\n    @Override\n    public void ride() {\n        System.out.println(\"Bicycle rides.\");\n    }\n\n    public static CycleFactory factory = new CycleFactory() {\n        @Override\n        public Cycle getCycle() {\n            return new Bicycle();\n        }\n    }; // 通过一个静态成员变量（类属性）来保存工厂生成的Bicycle\n}\n\npublic class Factory {\n    public static void cycleConsumer(CycleFactory factory) {\n        Cycle cycle = factory.getCycle();\n        cycle.ride();\n    }\n\n    public static void main(String[] args) {\n        cycleConsumer(Bicycle.factory); // 不需要实例工厂类\n    }\n}\n```\n\n#### 3. 对比\n- 通过在外围类中创建一个返回类型为`工厂接口（CycleFactory）`的方法，来创建一个`Bicycle`的工厂，并将该工厂用`类属性`（静态成员变量）保存，从而可以直接访问该静态成员变量以访问其工厂。\n- 工厂只需要一个，故使用匿名内部类创建工厂对象并由`类属性`保存，即可通过使用该`类属性`让工厂生产对象。","tags":["Java","设计模式"]},{"title":"简单说一下自己对封装、继承、多态的一些理解","url":"/2020/02/19/简单说一下自己对封装、继承、多态的一些理解/","content":"\n### 简单理解\n#### 1、封装\n封装的实质，是提供了新的数据类型。\n\n#### 2、继承\n从外部看，从父类（基类）继承得到的子类（导出类）就像一个与基类具有相同接口（非`interface`声明的接口）的新类。当创建了一个导出类的对象时，该对象就已经包含了一个基类的子对象。*继承带来了多态的便捷性。*\n\n导出类可以通过覆写（`@Override`）基类的方法，来使同一个方法根据自己特性的不同而产生不同的表现和作用。\n\n#### 3、多态\n多态，即将改变的事物与未变的事物分离开。\n\n通过继承而来的导出类，能够使用向上转型的方式，来达到**后期绑定**（也称为*动态绑定*或*运行时绑定*）。\n\n- **绑定**：将一个方法用同一个方法主体关联起来。\n- **后期绑定**：运行时根据对象的类型进行绑定。\n\n### 具体谈多态的特性\n先通过一段代码，来解释**普通类继承**、**抽象类继承**、**接口实现**分别如何实现多态。\n\n```java\nabstract class Transportation {\n    public Transportation() {\n        System.out.println(\"This is a transportation.\");\n    }\n\n    public abstract void forward();\n}\n\ninterface TransportPower {\n    void powerSource();\n}\n\nclass Car extends Transportation {\n    private wheelNum = 4;\n\n    public int getWheelNum() {\n        return wheelNum;\n    }\n\n    @Override\n    public void forward() {\n        System.out.println(\"Car goes forward.\");\n    }\n}\n\nclass OilCar extends Car implements TransportPower {\n    @Override\n    public void powerSource() {\n        System.out.println(\"Use oil as power.\");\n    }\n\n    public void highSpeed() {\n        System.out.println(\"OilCar can highSpeed.\");\n    }\n}\n```\n\n#### 1、普通类继承\n导出类不一定需要覆写基类的所有方法，导出类对象中包含了基类的子对象，故通过`getWheelNum()`方法，可以获得基类中的成员变量`wheelNum`。\n\n#### 2、抽象类继承\n抽象类的导出类必须覆写基类的抽象方法，赋予具体实现。\n\n#### 3、接口实现\n实现了某接口的类必须覆写接口中所有的方法，赋予具体实现。\n\n***所有导出类，都可以通过向上转型的方式，在运行时绑定，从而实现多态性。***\n\n### 抽象类与接口的区别\n1. 接口只能定义抽象方法，而抽象类可以定义非抽象方法。\n2. 类只能单继承，而接口可以多实现。\n\n#### 深层讲解\n参考链接：https://blog.csdn.net/aptentity/article/details/68942916\n\n- 抽象类\n    - 对类型进行隐藏，可以构造出一个固定的一组行为的抽象描述，一个行为可以有任意个可能的具体实现方式。这个抽象的描述就是抽象类。（即多态性的体现）\n    - 这一组任意个可能的具体实现表现为所有可能的导出类，模块可以操作一个抽象类，由于模块依赖于一个固定的抽象类，那么它是不允许修改的。同时通过这个抽象类进行派生，拓展此模块的行为功能。\n- 接口\n    - 接口可以补充Java只有单继承的特性，实现“多继承”。\n    - 把程序模块进行固化的契约，降低偶合。把若干功能拆分出来，按照契约来进行实现和依赖。\n    - 定义接口有利于代码的规范。\n\n***抽象类强调的是从属关系，接口强调的是功能。***","tags":["Java","面向对象"]},{"title":"如何部署Hexo博客到GitHub","url":"/2020/02/12/如何部署Hexo博客到GitHub/","content":"\n#### 一、准备环境\n- node.js\n- npm\n\n我的环境为MacOS环境。\n\n#### 二、安装hexo框架\n1. 切换到root用户\n```text\nsudo su\n```\n\n2. 安装npm淘宝源cnpm\n```text\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n3. 安装hexo\n```text\ncnpm install -g hexo-cli\n```\n\n#### 三、搭建博客\n1. 新建博客文件夹在`~`路径下\n```text\nmkdir <文件夹命名>\n```\n\n2. 初始化\n```text\nsudo hexo init\n```\n\n#### 四、启动博客\n- 用于在本地测试\n```text\nhexo s\n```\n\n#### 五、在github上新建开放仓库\n- 新建github.io仓库，必须以自己的用户名命名，如：\n```text\n<GitHub的用户名>.github.io\n```\n\n#### 六、安装git插件\n- 在博客文件夹目录下\n```text\ncnpm install --save hexo-deployer-git\n```\n\n#### 七、配置\n##### 配置推送的GitHub仓库\n- 编辑`_config.yml`文件，在最底部，配置：\n```yml\ndeploy:\n  type: git\n  repo: 仓库地址\n  branch: master\n```\n\n##### 更改主题\n1. 在`<博客根目录>`目录下，克隆主题，这里以yilia主题举例：\n```text\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n2. 配置`_config.yml`文件\n- 配置主题为yilia\n```yml\ntheme: yilia\n```\n\n#### 八、一些操作\n- 清除缓存\n```text\nhexo clean\n```\n\n- 在本地开启服务\n```text\nhexo s\n```\n\n- 推送到仓库\n```text\nhexo d\n```","tags":["环境搭建"]}]