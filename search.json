[{"title":"一份代码搞清楚内部类","url":"/2020/02/26/一份代码搞清楚内部类/","content":"\n最近学习神书《Java编程思想》，学习到第10章内部类的内容时，花了很久时间消化。现在基本搞懂了一些基本，用一份代码大致上总结了全章大部分内容。\n\n解释说明全部在代码中用注释标识，以供理解。\n\n```java\npackage com.blackside.chapter_10;\n\ninterface Counter {\n    int next();\n}\n\npublic class TestForInnerClass {\n    private String name = \"OuterClass\";\n    private int testCount;\n\n    private class InnerClass {\n        private String name = \"InnerClass\";\n\n        /**\n         * 当内部类与外围类具有相同名的成员属性时，如何区分？\n         * 内部类中，用this标识符指代内部类自己，用 外围类名.this 指代外围类\n         * @return\n         */\n        // 操作内部类的成员属性\n        public String returnInnerName() {\n            return this.name;\n        }\n\n        // 操作外围类的成员属性\n        public String returnOuterName() {\n            return TestForInnerClass.this.name;\n        }\n    }\n\n    /**\n     * 局部内部类\n     * 可以拥有构造器\n     * 局部内部类对象，对其外围类来说可以拥有多个，即内部类可以复用\n     * @param givenName\n     * @return\n     */\n    public Counter[] getLocalInnerClass(final String givenName) {\n        Counter[] counters = new Counter[2];\n\n        class LocalInnerClass implements Counter {\n            private String name = \"LocalInner\";\n            private int number;\n\n            // 局部内部类的构造器\n            public LocalInnerClass(int number) {\n                /**\n                 * 这里形参不允许被修改，则说明局部内部类的形参需要被定义为final\n                 */\n                this.number = number;\n//                givenName += \"Testing\";\n                System.out.println(\"I am LocalInnerClass \" + this.number + \".\");\n            }\n\n            @Override\n            public int next() {\n                System.out.print(TestForInnerClass.this.name + name + \" \" + givenName + \" \" + this.number + \" output \");\n                return testCount++;\n            }\n        }\n        // 这里，不匿名的局部内部类得到复用，可以创建多个该内部类的对象\n        counters[0] = new LocalInnerClass(1);\n        counters[1] = new LocalInnerClass(2);\n        return counters;\n    }\n\n    /**\n     * 匿名内部类\n     * 无法拥有构造器，但可以使用实例初始化的方式\n     * 匿名内部类对象对于其外围类，只能拥有一个，匿名内部类无法使用多次\n     * @param givenName\n     * @return\n     */\n    public Counter getAnonymousInner(final String givenName) {\n        // 返回的匿名内部类对象一次性返回，且只产生一个对象，无法复用\n        return new Counter() {\n            private String name = \"LocalAnonymousClass\";\n\n            // 匿名内部类无法拥有构造器，这里使用实例初始化的方式\n            {\n                /**\n                 * 这里形参不允许被修改，则说明局部内部类的形参需要被定义为final\n                 */\n//                givenName += \"Testing\";\n                System.out.println(\"I am LocalAnonymousInnerClass.\"); // 匿名内部类无法拥有构造器，可以使用实例初始化的方式\n            }\n\n            @Override\n            public int next() {\n                System.out.print(TestForInnerClass.this.name + \" \" + name + \" \" + givenName + \" output \");\n                return testCount++;\n            }\n        };\n    }\n\n    public InnerClass getInnerClass() {\n        return new InnerClass();\n    }\n\n    public static void main(String[] args) {\n        TestForInnerClass test = new TestForInnerClass();\n\n        InnerClass innerClass = test.getInnerClass();\n        System.out.println(innerClass.returnInnerName());\n        System.out.println(innerClass.returnOuterName());\n\n        Counter[] localInner = test.getLocalInnerClass(\"001\");\n        System.out.println(localInner[0].next());\n        System.out.println(localInner[1].next());\n\n        Counter anonymousInner = test.getAnonymousInner(\"002\");\n        System.out.println(anonymousInner.next());\n    }\n}\n```","tags":["Java"]},{"title":"简单谈匿名内部类用在工厂方法的理解","url":"/2020/02/24/简单谈匿名内部类用在工厂方法的理解/","content":"\n### 简单说内部类\n- 将一个类定义在另一个类的定义内部，就是内部类，而这里的另一个类被称为**外围类**（或外部类）。\n- 内部类对象被外围类（外部类）创建时，会自动拥有一个指向该外围类的引用，还包含外围类对象的信息（闭包）。这意味着，内部类可以直接操作外围类的成员，即是是私有（private）的成员属性与方法，而无需实例出外围类的对象（因为自动拥有）。\n- 由于Java的继承是单继承，而每个内部类都能够独立地继承自一个（接口的）实现，也即，内部类为外围类提供了“可以继承多个具体或抽象的类”的能力。\n- 类的实质是一种新的数据类型，创建私有（private）的内部类即同理创建一个具有新数据结构的私有成员。\n\n### 匿名内部类\n匿名内部类通过一个返回值为基类接口（向上转型）的方法创建出一个没有类名的对象。简单来看：\n\n```java\nclass A {\n    void say() {\n        System.out.println(\"I am A.\");\n    }\n}\n\npublic class B {\n    public A createA() {\n        return new A() {\n            @Override\n            public void say() {\n                System.out.println(\"I am inside B.\");\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        B b = new B();\n        A a = b.createA();\n        a.say();\n    }\n}\n\n/**\n* Output:\n* I am inside B.\n*/\n```\n匿名内部类简化了代码，由于不具有类名，匿名内部类只被使用一次。接下来看看工厂方法中使用匿名内部类以简化代码。\n\n### 工厂方法\n#### 1. 先看不使用匿名内部类实现的工厂方法\n\n```java\ninterface Cycle {\n    void ride();\n}\n\ninterface CycleFactory {\n    Cycle getCycle();\n}\n\nclass Bicycle implements Cycle {\n    @Override\n    public void ride() {\n        System.out.println(\"Bicycle rides.\");\n    }\n}\n\nclass BicycleFactory implements CycleFactory {\n    @Override\n    public Cycle getCycle() {\n        return new Bicycle();\n    }\n}\n\npublic class Factory {\n    public static void cycleConsumer(CycleFactory factory) {\n        Cycle cycle = factory.getCycle();\n        cycle.ride();\n    }\n\n    public static void main(String[] args) {\n        cycleConsumer(new BicycleFactory());\n    }\n}\n```\n\n#### 2. 再看使用了匿名内部类的工厂方法\n\n```java\ninterface Cycle {\n    void ride();\n}\n\ninterface CycleFactory {\n    Cycle getCycle();\n}\n\nclass Bicycle implements Cycle {\n    @Override\n    public void ride() {\n        System.out.println(\"Bicycle rides.\");\n    }\n\n    public static CycleFactory factory = new CycleFactory() {\n        @Override\n        public Cycle getCycle() {\n            return new Bicycle();\n        }\n    }; // 通过一个静态成员变量（类属性）来保存工厂生成的Bicycle\n}\n\npublic class Factory {\n    public static void cycleConsumer(CycleFactory factory) {\n        Cycle cycle = factory.getCycle();\n        cycle.ride();\n    }\n\n    public static void main(String[] args) {\n        cycleConsumer(Bicycle.factory); // 不需要实例工厂类\n    }\n}\n```\n\n#### 3. 对比\n- 通过在外围类中创建一个返回类型为`工厂接口（CycleFactory）`的方法，来创建一个`Bicycle`的工厂，并将该工厂用`类属性`（静态成员变量）保存，从而可以直接访问该静态成员变量以访问其工厂。\n- 工厂只需要一个，故使用匿名内部类创建工厂对象并由`类属性`保存，即可通过使用该`类属性`让工厂生产对象。","tags":["Java","设计模式"]},{"title":"简单说一下自己对封装、继承、多态的一些理解","url":"/2020/02/19/简单说一下自己对封装、继承、多态的一些理解/","content":"\n### 简单理解\n#### 1、封装\n封装的实质，是提供了新的数据类型。\n\n#### 2、继承\n从外部看，从父类（基类）继承得到的子类（导出类）就像一个与基类具有相同接口（非`interface`声明的接口）的新类。当创建了一个导出类的对象时，该对象就已经包含了一个基类的子对象。*继承带来了多态的便捷性。*\n\n导出类可以通过覆写（`@Override`）基类的方法，来使同一个方法根据自己特性的不同而产生不同的表现和作用。\n\n#### 3、多态\n多态，即将改变的事物与未变的事物分离开。\n\n通过继承而来的导出类，能够使用向上转型的方式，来达到**后期绑定**（也称为*动态绑定*或*运行时绑定*）。\n\n- **绑定**：将一个方法用同一个方法主体关联起来。\n- **后期绑定**：运行时根据对象的类型进行绑定。\n\n### 具体谈多态的特性\n先通过一段代码，来解释**普通类继承**、**抽象类继承**、**接口实现**分别如何实现多态。\n\n```java\nabstract class Transportation {\n    public Transportation() {\n        System.out.println(\"This is a transportation.\");\n    }\n\n    public abstract void forward();\n}\n\ninterface TransportPower {\n    void powerSource();\n}\n\nclass Car extends Transportation {\n    private wheelNum = 4;\n\n    public int getWheelNum() {\n        return wheelNum;\n    }\n\n    @Override\n    public void forward() {\n        System.out.println(\"Car goes forward.\");\n    }\n}\n\nclass OilCar extends Car implements TransportPower {\n    @Override\n    public void powerSource() {\n        System.out.println(\"Use oil as power.\");\n    }\n\n    public void highSpeed() {\n        System.out.println(\"OilCar can highSpeed.\");\n    }\n}\n```\n\n#### 1、普通类继承\n导出类不一定需要覆写基类的所有方法，导出类对象中包含了基类的子对象，故通过`getWheelNum()`方法，可以获得基类中的成员变量`wheelNum`。\n\n#### 2、抽象类继承\n抽象类的导出类必须覆写基类的抽象方法，赋予具体实现。\n\n#### 3、接口实现\n实现了某接口的类必须覆写接口中所有的方法，赋予具体实现。\n\n***所有导出类，都可以通过向上转型的方式，在运行时绑定，从而实现多态性。***\n\n### 抽象类与接口的区别\n1. 接口只能定义抽象方法，而抽象类可以定义非抽象方法。\n2. 类只能单继承，而接口可以多实现。\n\n#### 深层讲解\n参考链接：https://blog.csdn.net/aptentity/article/details/68942916\n\n- 抽象类\n    - 对类型进行隐藏，可以构造出一个固定的一组行为的抽象描述，一个行为可以有任意个可能的具体实现方式。这个抽象的描述就是抽象类。（即多态性的体现）\n    - 这一组任意个可能的具体实现表现为所有可能的导出类，模块可以操作一个抽象类，由于模块依赖于一个固定的抽象类，那么它是不允许修改的。同时通过这个抽象类进行派生，拓展此模块的行为功能。\n- 接口\n    - 接口可以补充Java只有单继承的特性，实现“多继承”。\n    - 把程序模块进行固化的契约，降低偶合。把若干功能拆分出来，按照契约来进行实现和依赖。\n    - 定义接口有利于代码的规范。\n\n***抽象类强调的是从属关系，接口强调的是功能。***","tags":["Java","面向对象"]},{"title":"如何部署Hexo博客到GitHub","url":"/2020/02/12/如何部署Hexo博客到GitHub/","content":"\n#### 一、准备环境\n- node.js\n- npm\n\n我的环境为MacOS环境。\n\n#### 二、安装hexo框架\n1. 切换到root用户\n```text\nsudo su\n```\n\n2. 安装npm淘宝源cnpm\n```text\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n3. 安装hexo\n```text\ncnpm install -g hexo-cli\n```\n\n#### 三、搭建博客\n1. 新建博客文件夹在`~`路径下\n```text\nmkdir <文件夹命名>\n```\n\n2. 初始化\n```text\nsudo hexo init\n```\n\n#### 四、启动博客\n- 用于在本地测试\n```text\nhexo s\n```\n\n#### 五、在github上新建开放仓库\n- 新建github.io仓库，必须以自己的用户名命名，如：\n```text\n<GitHub的用户名>.github.io\n```\n\n#### 六、安装git插件\n- 在博客文件夹目录下\n```text\ncnpm install --save hexo-deployer-git\n```\n\n#### 七、配置\n##### 配置推送的GitHub仓库\n- 编辑`_config.yml`文件，在最底部，配置：\n```yml\ndeploy:\n  type: git\n  repo: 仓库地址\n  branch: master\n```\n\n##### 更改主题\n1. 在`<博客根目录>`目录下，克隆主题，这里以yilia主题举例：\n```text\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n2. 配置`_config.yml`文件\n- 配置主题为yilia\n```yml\ntheme: yilia\n```\n\n#### 八、一些操作\n- 清除缓存\n```text\nhexo clean\n```\n\n- 在本地开启服务\n```text\nhexo s\n```\n\n- 推送到仓库\n```text\nhexo d\n```","tags":["环境搭建"]}]