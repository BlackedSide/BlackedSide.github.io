[{"title":"记一个ThreadLocal问题来聊聊这个玩意","url":"/记一个ThreadLocal问题来聊聊这个玩意.html","content":"\n### 问题引出\n今天学习《Java并发编程的艺术》一书第4章中ThreadLocal的问题，书中对ThreadLocal的讲解和使用篇幅较短，于是自己做了一些小实验，过程中遇到了一个问题。问题代码如下：\n\n```java\nclass Person {\n    String name;\n\n    Person(String name) {\n        this.name = name;\n    }\n\n    public String toString() {\n        return name;\n    }\n}\n\nclass ThreadLocalIs implements Runnable {\n    ThreadLocal<Person> threadLocal = new ThreadLocal<>();\n    Integer value;\n\n    public void set(Person value) {\n        threadLocal.set(value);\n    }\n\n    public void set(Integer value) {\n        this.value = value;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(value);\n        System.out.println(threadLocal.get());\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n    ThreadLocalIs is = new ThreadLocalIs();\n    Person fan = new Person(\"Fan\");\n    is.set(fan);\n    is.set(25);\n    Thread t = new Thread(is);\n    t.start();\n}\n/**\n* Output:\n* 25\n* null\n*/\n```\n\n可以看到，在输出中，对`is`引用的`ThreadLocalIs`对象中的`Integer`类型的`value`赋值被成功输出，对`ThreadLocal`类型的`threadLocal`变量的赋值却丢失了。折腾了很久，才搞明白是怎么回事。\n\n### 原因\n这是因为，`ThreadLocal`对象隶属于线程管理，而非对象管理。也就是说，虽然`is`对象中声明了一个`ThreadLocal`对象，但是对它的赋值操作却是在线程中执行的，也即`main`线程中进行的赋值，那么，`main`线程中中的`ThreadLocalMap`类型的`threadLocals`中就会挂载`is`对象中的`threadLocal`对象。也即，该`ThreadLocal`对象属于`main`线程，而不属于`is`对象。如果将`set()`操作放在`ThreadLocalIs`类中的`run()`方法内执行，那么该`ThreadLocal`对象就会挂载在新建它的线程上，也即`t`上。\n\n### ThreadLocal\n关于ThreadLocal的原理源码分析啥的这里就不再赘述，网上有很多优质的博文做了详细的介绍说明。这里给出一些自己的理解总结：\n- ThreadLocal，线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构，例如：`ThreadLocal<Person> obj = new ThreadLocal<>(); Person fan = new Person(); obj.set(fan);`代码中，对于该线程中，obj为键，fan对象为值。线程可以根据obj对象（ThreadLocal对象）查找到fan对象（值）。\n- 每个线程维护一个ThreadLocalMap，该Map中存放着所有在该线程中注册的ThreadLocal键值对对象。因此，ThreadLocal是线程隔离的，也即线程安全的。","tags":["Java","多线程"]},{"title":"来一个八大排序算法小总结","url":"/来一个八大排序算法小总结.html","content":"\n>参考文章：https://juejin.im/post/5ab9ae9cf265da23830ae617\n\n排序是算法排在前面的知识内容，已经很久没有回顾了。今天心情凌乱，就把八大排序算法做个小总结吧，算作是一次小小的复习与回顾。\n\n## 1. 冒泡排序\n思路：\n- 两两交换，将大的元素交换到后面（从小到大排序的情况下），没经过一轮，就能确定最后一个元素是最大值。\n\n```java\nfor (int i = 0; i < arrays.length - 1; i++) { // 外层循环控制排序的趟数\n    isChange = 0; // 每比较完一趟就置0\n    for (int j = 0; j < arrays.length - i - 1; j++) { // 内层循环控制比较交换的次数\n        if (arrays[j] > arrays[j+1]) {\n            swap(arrays[j], arrays[j+1]);\n        }\n        isChange = 1;\n    }\n    if (isChange == 0) { // 如果当前趟次没有发生交换，则说明排序已经完成\n        break;\n    }\n}\n```\n\n复杂度分析：\n- 时间：O(n^2)\n- 空间：O(1)\n- 稳定\n\n## 2. 选择排序\n思路：\n- 找到数组中的最大值，与数组的最后一个元素交换（从小到大排序的情况下）。\n\n```java\nfor (int i = 0; i < arrays.length - 1; i++) { // 外层控制排序趟数\n    pos = 0; // 新的趟数时，将下标归零\n    for (int j = 0; j < arrays.length - i; j++) { // 内层控制选择最大值循环\n        if (arrays[j] > arrays[pos]) {\n            pos = j;\n        }\n    }\n    swap(arrays[pos], arrays[arrays.length - i - 1]); // 将本趟寻找到的最大值与本趟末尾元素置换\n}\n```\n\n复杂度分析：\n- 时间：O(n^2)\n- 空间：O(1)\n- 不稳定\n\n## 3. 插入排序\n思路：\n- 将一个元素插入到已经有序的数组中，初始时将第一个元素当做有序数组。\n- 与有序数组末尾元素进行比较，若大于则直接放入有序数组末尾（即当前位置不动），若小于则插入到合适位置，并进行移动。\n\n```java\nint temp; // 临时变量\nfor (int i = 1; i < arrays.length; i++) { // 外层控制排序趟数\n    temp = arrays[i];\n    int j = i - 1;\n    while (j >= 0 && arrays[j] > temp) { // 内层寻找插入位置\n        arrays[j+1] = arrays[j]; // 向前交换，找到合适的插入位置\n        j--;\n    }\n    arrays[j+1] = temp; // 将temp元素插入找到的有序数组中的位置\n}\n```\n\n算法复杂度：\n- 时间：O(n^2)\n- 空间：O(1)\n- 稳定\n\n## 4. 快速排序\n思路：\n- 在数组中找一个元素，比它小的放在它左边，比它大的放在它右边，一趟下来，比当前元素小的都在左边，大的都在右边。\n\n```java\npublic static void quickSort(int[] arrays, int left, int right) {\n    int j = left;\n    int i = right;\n\n    int pivot = arrays[(left + right) / 2];\n\n    while (i <= j) {\n        while (pivot > arrays[i]) {\n            i++;\n        }\n        while (pivot < arrays[j]) {\n            j--;\n        }\n        if (i <= j) {\n            swap(arrays[i], arrays[j]);\n            i++;\n            j--;\n        }\n    }\n\n    if (left < j) {\n        quickSort(arrays, left, j);\n    }\n    if (right > i) {\n        quickSort(arrays, i, right);\n    }\n}\n```\n\n算法复杂度：\n- 时间：O(nlogn)\n- 空间：O(nlogn)\n- 不稳定\n\n## 5. 归并排序\n思路：\n- 将两个已经排序好的数组合并成一个有序数组。\n    - 将元素分隔开，看成有序数组，进行比较合并；\n    - 不断拆分与合并，直到拆分成一个元素为止。\n\n```java\npublic static void mergeSort(int[] arrays, int left, int right) {\n    if (left == right) { // 只剩余一个元素的时候，就不需要排序了\n        return;\n    } else {\n        int mid = (left + right) >> 1;\n        mergeSort(arrays, left, mid);\n        mergeSort(arrays, mid+1, right);\n        merge(arrays, left, mid+1, right);\n    }\n}\n\nstatic void merge(int[] arrays[], int left, int mid, int right) {\n    int[] leftArr = new int[mid - left];\n    int[] rightArr = new int[right - mid + 1];\n\n    for (int i = left; i < mid; i++) {\n        leftArr[i - left] = arrays[i];\n    }\n    for (int i = mid; i <= right; i++) {\n        rightArr[i - mid] = arrays[i];\n    }\n\n    int i = 0, j = 0;\n    int k = left; // 指向数组最左端元素\n\n    while (i < leftArr.length && j < rightArr.length) {\n        if (leftArr[i] < rightArr[j]) {\n            arrays[k] = leftArr[i];\n            i++;\n            k++;\n        } else {\n            arrays[k] = rightArr[j];\n            j++;\n            k++;\n        }\n    }\n\n    while (i < leftArr.length) {\n        arrays[k] = leftArr[i];\n        i++;\n        k++;\n    }\n    while (j < rightArr.length) {\n        arrays[k] = rightArr[j];\n        j++;\n        k++;\n    }\n}\n```\n\n算法复杂度：\n- 时间：O(nlogn)\n- 空间：O(n)\n- 稳定\n\n## 6. 堆排序\n思路：\n- 利用二叉树性质，要求父节点比左右孩子节点都大（大顶堆）。\n- 由于二叉树由数组存储，故对于某个节点`i`，其左节点下标为`2i`，右节点下标为`2i+1`。若存在数组`0`下标作为哨兵交换节点的情况，则对于节点`i`，其左节点为`2i+1`，右节点为`2i+2`。\n\n```java\npublic static void buildHeap(int[] arrays, int size) {\n    for (int i = size-1; i >= 0; i--) {\n        heapify(arrays, i, size);\n    }\n}\n\nstatic void heapify(int[] arrays, int currentRootNode, int size) {\n    if (currentRootNode < size) {\n        // arrays[0]作为哨兵，不存值，用于作为交换buffer\n        int left = 2 * currentRootNode + 1;\n        int right = 2 * currentRootNode + 2;\n\n        int max = currentRootNode;\n\n        if (left < size) {\n            if (arrays[max] < arrays[left]) {\n                max = left;\n            }\n        }\n        if (right < size) {\n            if (arrays[max] < arrays[right]) {\n                max = right;\n            }\n        }\n\n        if (max != currentRootNode) {\n            swap(arrays[currentNodeRoot], arrays[max]);\n            heapify(arrays, max, size);\n        }\n    }\n}\n```\n\n算法复杂度：\n- 时间：O(nlogn)\n- 空间：O(1)\n- 不稳定\n\n## 7. 希尔排序\n思路：\n- 本质上是插入排序的增强版，希尔排序将数组分隔为n组来进行插入排序，直至总体有序。\n\n```java\nvoid shellSot(int[] arrays) {\n    for (int step = arrays.length / 2; step > 0; step /= 2) {\n        for (int i = step; i < arrays.length; i++) {\n            int j = i;\n            int temp = arrays[j];\n\n            while (j-step >= 0 && arrays[j-step] > temp) {\n                arrays[j] = arrays[j-step];\n                j -= step;\n            }\n            arrays[j] = temp;\n        }\n    }\n}\n```\n\n算法复杂度：\n- 时间：O(n^(1.5))\n- 空间：O(1)\n- 不稳定\n\n## 8. 基数排序（桶排序）\n思路：\n- 将数字切割成个、十、百、千位放入到不同的桶子里，放一次就按桶子顺序回收一次，直至最大位数的数字放完。\n\n```java\nvoid radixSort(int[] arrays) {\n    int max = findMax(arrays, 0, arrays.length-1);\n\n    // 遍历次数由最大值的位数决定\n    for (int i = 1; max/i >= 0; i *= 10) {\n        int[][] buckets = new int[arrays.length][10];\n\n        // 获取每一位数字放入桶中\n        for (int j = 0; j < arrays.length; j++) {\n            int num = (arrays[j] / i) % 10;\n            buckets[j][num] = arrays[j];\n        }\n\n        int k = 0;\n\n        for (int j = 0; j < 10; j++) {\n            // 对每个桶中的元素进行回收\n            for (int l = 0; l < arrays.length; l++) {\n                // 若桶中有数据则回收\n                if (buckets[l][j] != 0) {\n                    arrays[k++] = buckets[l][j];\n                }\n            }\n        }\n    }\n}\n\nvoid findMax(int[] arrays, int left, int right) {\n    if (left == right) {\n        return arrays[left];\n    } else {\n        int a = arrays[left];\n        int b = findMax(arrays, left+1, right); // 找出整体的最大值\n\n        if (a > b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n}\n```\n\n算法复杂度：\n- 时间：O(d * (r + n)) 其中，d表示长度，r代表关键字的基数，n代表关键字的个数\n- 空间：O(d * r + n)\n- 稳定","tags":["数据结构","算法"]},{"title":"让Google能够搜索到你的Hexo博客","url":"/让Google能够搜索到你的Hexo博客.html","content":"\n博客建好已经小半年了，今天偶尔来了兴致去Google上Google了一下自己的博客，卧槽。。检索不到（本以为时间久了就能检索到了）。。于是重新查阅了资料，将自己的博客网站部署到了Google Search上，详述一下步骤。\n\n## 进入Google Search官网，添加自己的博客网站\n1. [https://search.google.com/search-console](https://search.google.com/search-console)\n2. 添加资源，我使用的【网址前缀】作为选项，并添加了自己的`https://GitHub用户名.github.io`网址。\n3. 我使用的是【HTML标签验证】，复制它给的`<meta>`标签。\n4. 将整个meta标签添加到`Hexo博客根目录/themes/你使用的主题/layout/_partials`下找到`head.***`文件打开，将meta标签添加上。\n5. 保存后，重新`hexo deploy`一下就可以验证成功了。\n\n## 添加站点地图\n1. 首先在Hexo根目录下执行`npm install hexo-generator-sitemap --save`命令。\n2. 在`_config.yml`文件下添加如下字段：\n```yml\nurl: https://blackedside.github.io # 你网站的地址\n\nsitemap:\n  path: sitemap.xml # 用于生成站点地图\n```\n3. 保存后，`hexo generate`一下，然后重新deploy一下。\n4. 在Google Search中添加新的站点地图，把sitemap.xml写入你网站的后缀中即可。\n\n搞定。","tags":["环境搭建"]},{"title":"知不知道数据库与B/B+树的关联","url":"/知不知道数据库与B-B-树的关联.html","content":"\n终于弄清楚B-树原来就TM是B树了，今天终于看懂了（看到了）B树与B+树的简单原理，可以回答**为啥MySQL数据库使用B+树存储索引**的问题了。这篇文章不再赘述B树/B+树的概念、结构等原理，主要讲一讲这两者的关系与区别，以及为什么关系型数据库（如MySQL）使用B+树存储索引而非关系型数据库（如MongoDB）使用B树作为存储索引的数据结构。\n\n## 首先讲讲B树作为数据结构存储的优点\n众所周知，使用传统的平衡二叉树（如AVL树、红黑树）来作为查找数据结构的查询性能非常赞。存储少量数据时，使用AVL树来做索引当然很棒，因为数据直接读入内存操作，效率很高。但是当存储海量数据时，一次性将所有数据读入内存不现实，因此需要在磁盘内直接进行查找，这意味着磁盘IO的操作为查找性能带来了挑战。因此，降低IO次数便是存储海量数据索引的一个亟需解决的问题。对于二叉树而言，由于层数较高，达到了logN层（N为节点个数，也就是数据的个数，因为二叉树一个节点只存出一个数据），因此，查找一个数据的IO次数也达到了logN的级别。而B树采用多叉的结构，目标是将树的层数压缩在3（通常来说），从而大大减少了磁盘的IO次数，增加了查找效率。\n\n所以说，B树作为数据结构存储数据的目的是为了压缩树的高度，从而减少在海量数据查找情况下，降低磁盘IO的次数，从而从真实世界的时间概念上进行优化。（也就是说此时不能从算法时间复杂度来作唯一考量了。）\n\n## B树与B+树的区别\n细节上的区别也不在此篇赘述，主要讲讲作为存储结构，最大的区别就在于，B树直接将数据存储在索引的指针指向上，即，树中的节点直接存储数据；而B+树则在所有非叶子节点上只存放索引，而只有在叶子节点上才真正存储数据，并且在树的最后一层上，每个数据按序拥有指针（即所有叶子节点构成链表结构，数据的索引具有连续性和有序性）。也正是因此，B+树的结构支持区间查找，可以很好地利用磁盘的**预读**机制，即B+树相对于B树增加了**区间访问性**。\n\n除此之外，由于B+树的非叶子节点只存储索引副本，而不存储真实的数据，因此，对于相同大小的磁盘块，B树能存储的索引较小，而B+树能存储更多的索引，因此每个节点能索引的范围更大也更精确，从而更好地减小磁盘的IO次数。\n\n## 该说说MongoDB和MySQL了\n大家知道，MongoDB作为一种非关系型数据库（也是聚合型数据库），使用的存储结构是B树；而MySQL作为一种关系型数据库，使用的是B+树，Why is 这样？\n\n### MongoDB\n从**聚合性数据库**这个字眼就能看出，这种类型的数据库很好地迎合了B树的聚合特性（索引与数据直接绑定存储在一个节点里）。而且，B树的查找效率最好可以达到O(1)（即在根节点就查找到），如此也很好地迎合了非关系型数据库对性能要求高（但数据模型要求简单）的需求。简单来说，B树查找到了索引，也即立马获取到了数据。\n\n### MySQL\nB+树查询效率稳定，固定在logN（log底数很大，因此logN并不大），因为所有数据都在叶子节点中，也即树的最后一层上，所以查询效率稳定。更重要的是，关系型数据库具有很普遍的区间访问需求，而B树不支持区间访问，B+树也能很好地利用磁盘预读机制迎合关系型数据库区间访问的需求。另外，由于B+树的每个节点的索引范围更大更精确，因此也更适合外部存储（减少磁盘IO次数）。\n\n讲完了。","tags":["数据结构","数据库"]},{"title":"从模板方法模式看Comparable接口与Comparator接口","url":"/从模板方法模式看Comparable接口与Comparator接口.html","content":"\n今天学习《Head First 设计模式》中的模板方法模式（Template Pattern），其中一节讲到数组的排序`sort()`使用到了模板方法模式中的技巧。由于`Comparable`接口与`Comparator`接口尚不熟悉，故趁此机会将模板方法模式在`sort()`方法中的体现，以及两个比较接口的使用方式与比较做一个简单总结。\n\n书中首先给出了如下源码：\n```java\npublic static void sort(Object[] a) {\n    Object aux[] = (Object[])a.clone();\n    mergeSort(aux, a, 0, a.length, 0);\n}\n\nprivate static void mergeSort(Objcet src[], Object dest[], int low, int high, int off) {\n    for (int i = low; i < high; i++) {\n        for (int j = i; j > low && ((Comparable)dest[j-1]).compareTo((Comparable)dest[j]) > 0; j--) {\n            swap(dest, j, j-1);\n        }\n    }\n    return;\n}\n```\n可以看到，`mergeSort()`方法中基于`compareTo()`方法进行排序，这就要求被排序的对象给出了该方法的具体实现，也即，实现了`Comparable`接口中的`compareTo()`方法。\n\n## 首先来看Comparable接口与Comparator接口\n给出如下类定义：\n```java\npublic class Person {\n    String name;\n    int age;\n}\n```\n要实现`Person`对象可排序，有以下两种实现方法：\n### Comparable接口\n```java\npublic class Person implements Comparable<Person> {\n    /**\n    * 属性\n    */\n\n    @Override\n    public int compareTo(Person person) { // 实现按照Person的年龄（age）从大到小排序（也可以把逻辑反过来写实现从小到大排序）\n        if (this.age < person.age) {\n            return -1;\n        } else if (this.age == person.age) {\n            return 0;\n        } else {\n            return 1; // 则交换当前对象与person对象的位置，实现从大到小排序\n        }\n        // 也可以直接写成 return this.age.compareTo(person.age);\n    }\n}\n\n// 排序方式\n// 事先定义了一个Person对象的数组people[]\nArrays.sort(people);\n```\n\n### Comparator接口\n```java\n// 排序方式\n// 事先定义了一个Person对象的数组people[]\nArrays.sort(people, new Comparator<Person>() {\n    @Override\n    public int compare(Person p1, Person p2) {\n        return p1.age - p2.age; // 若返回值为正值，则交换p1对象和p2对象的位置，实现从大到小排序\n    }\n});\n```\n\n## Comparable和Comparator的比较\n- 实现`Comparable`接口需要在类的内部实现比较方法，需要对比较类进行修改；\n- `Comparable`接口只能实现一种比较方式；\n- `Comparator`则更灵活，通过传入一个比较器对象（可以通过如上所示的匿名内部类形式），可以实现不同形式的比较方法。\n\n## 为啥是模板方法模式而非策略模式\n摘自《Head First 设计模式》原话：\n```text\n在策略模式中，你所组合的类实现了整个算法。数组所实现的排序算法并不完整，它需要一个类填补compareTo()方法的实现。因此，我们认为这更像模板方法。\n```\n对于`Comparable`接口中的`compareTo()`来说，其`sort()`方法便是一个模板方法，其中定义了`mergeSort()`的实现，而需要客户提供`compareTo()`方法的具体实现，填补了模板方法中步骤方法的细节。","tags":["Java","设计模式"]},{"title":"数组的sort()方法与浅拷贝、深拷贝","url":"/数组的sort-方法与浅拷贝、深拷贝.html","content":"\n今天在学习《Head First 设计模式》模板方法模式一章中，阅读到了数组的`sort()`方法的源码，其中使用了`clone()`对数组进行了一份复制，再对其进行排序。之前没有接触过`clone()`方法，今天查阅资料，了解了Java中的浅拷贝与深拷贝的概念，简单谈谈自己的理解。\n\n## 概念\n- **浅拷贝**：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对主对象进行拷贝，但不会复制主对象里面的对象。里面的对象会在原来的对象和它的副本之间共享。即，若对象中的属性是基本类型，拷贝的就是基本类型的值；若对象中的属性是引用类型，则拷贝它的内存地址，故拷贝对象与被拷贝对象两者对该引用类型的修改，都会对彼此所持有的该属性有影响。\n- **深拷贝**：深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。即当对象和它所引用的对象一起拷贝时为深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。\n\n## 实现\n实现了`Cloneable`接口的类具有可以被拷贝的功能，同时，需要重写`clone()`方法。\n- 浅拷贝实现：\n```java\n@Override\npublic Object clone() {\n    try {\n        return super.clone(); // 直接调用父类的clone()方法\n    } catch (CloneNotSupportedException e) {\n        return null;\n    }\n}\n```\n- 深拷贝实现：\n```java\n/**\n* 假如Student类实现了Cloneable接口，且持有一个Teacher对象\n*/\n\n@Override\npublic Object clone() {\n    Student student = (Student) super.clone(); // 先进行浅拷贝拷贝所有非引用类型的属性\n    student.setTeacher((Teacher) student.getTeacher().clone()); // 再将所持有的引用类型（Teacher对象）进行一次浅拷贝，并赋值给拷贝对象所持有的引用类型属性\n    return student; // 此时返回的拷贝对象，就持有了一个具有被拷贝对象相同引用类型属性的对象，且拷贝对象持有的该对象与被拷贝对象持有的对象不是同一个对象（内存地址不同）\n}\n```","tags":["Java"]},{"title":"常量池？讲讲Java包装类与自动拆装箱","url":"/常量池？讲讲Java包装类与自动拆装箱.html","content":"\n今天遇见一个有趣的例子：\n```java\nInteger a = 40;\nInteger b = 40;\nInteger c = 400;\nInteger b = 400;\n\nSystem.out.println(a == b); // true\nSystem.out.println(c == b); // false\n```\n这是为啥？原来是Java中存在一个名为`IntegerCache`的静态类，其中的静态代码块会创建一个包含-128\\~127的整型数组，若使用`Integer`创建的值范围在-128\\~127之间，就直接使用该**常量池**中的数据，否则就新建一个对象。基于此，重新复习了一遍Java中的基本数据类型包装类与自动装箱、自动拆箱的机制。\n\n## 一、为什么要有包装类\nJava是面向对象语言，其宗旨是一切皆对象。可是，Java中包含着八大基本数据类型，它们不具有对象的特征。于是，便有了包装类，让基本数据类型具有对象的特性，同时拥有一系列自己的属性与操作方法。\n\n## 二、装箱？拆箱？\n看如下定义：\n```java\nInteger a = new Integer(50); // (1)\nInteger b = 50; // (2)\nint c = b; // (3)\n```\n如上所示，`Integer`是一个类，理应通过方法（1）使用`new`关键字创建一个对象，而方法（2）中却可以直接让一个基本数据类型赋值给一个类，方法（3）则将一个对象赋值给了基本数据类型。这之中就使用了装箱（方法2，调用了`Integer.valueOf()`方法）和拆箱（方法3，调用了`Integer.intValue()`方法）。其他基本数据类型的拆箱装箱也类似。\n\n## 三、丰富的例子\n```java\nInteger i1 = 40;\nInteger i2 = 40;\nInteger i3 = 0;\nInteger i4 = new Integer(40);\nInteger i5 = new Integer(40);\nInteger i6 = new Integer(0);\n\nSystem.out.println(i1 == i2); // (1) true\nSystem.out.println(i1 == i2 + i3); // (2) true\nSystem.out.println(i1 == i4); // (3) false\nSystem.out.println(i4 == i5); // (4) false\nSystem.out.println(i4 == i5 + i6); // (5) true\nSystem.out.println(40 == i5 + i6); // (6) true\n```\n解释一下上面的6个例子的结果。\n- （1）使用自动装箱调用了`Integer.valueOf()`方法，其中，传入的`int`值范围在-128\\~127之间，则直接从常量池中取对象，故`i1`和`i2`指向了同一个对象，结果相等。\n- （2）`+`操作符不适用于类`Integer`，故`i2 + i3`的过程中使用了自动拆箱得到结果为`40`，随后又与对象`i1`进行比较，`i1`使用了自动拆箱为`40`，进行数值比较，结果相等。\n- （3）注意，常量池的使用触发条件是调用了`Integer.valueOf()`方法，若使用`new`新建对象，则不会使用常量池中的对象，而是重新建立一个对象，故`i1`与`i4`指向的是不同的对象，结果不相等。\n- （4）与（3）同理，都是新建了一个对象。\n- （5）与（2）同理，`+`操作符是基本数据类型操作符，后面的表达式`i5 + i6`使用了自动拆箱，得到结果为`40`，再使`i4`自动拆箱，进行数值比较，结果相等。\n- （6）与（5）同理。\n\n## 四、有必要提一下==操作符与Object类的equals()方法\n- **==**：判断两个对象的地址是否相等，即判断两个对象是否是同一个对象。若==两端是基本数据类型，则比较它们的值是否相等，若是引用类型，则比较它们的内存地址是否相等。\n- **equals()方法**：同样是判断两个对象的地址是否相等。但该方法可以被重写（覆盖），用于比较值是否相等（如`String`类中就重写了`equals()`方法，当两个字符串对象的内容是一样的，就返回`true`）。\n\n## 五、那就有必要顺带一提hashCode()方法\n为啥重写了`equals()`方法就必须重写`hashCode()`方法？\n\n众所周知，`hashCode()`是用于生成散列码，用于作为散列表的插入与查找标记。当两个对象的`hashCode()`相同时，表明它们位于桶中的同一个位置，却不代表它们是同一个对象，因为桶中的该位置还会有一个链表用于解决哈希冲突。此时会再调用`equals()`方法判断是否真的是同一个对象，若不是，则会在链上继续查找（或插入），若是，则返回（或不插入新的）。故两个相同的对象具有相同的`hashCode`，也令`equals()`返回值为`true`；但具有相同`hashCode`的两个对象不一定是同一对象，也即`equals()`可能返回`false`。故重写了`euqals()`方法也需要重写`hashCode()`方法。","tags":["Java"]},{"title":"从JVM堆栈的角度浅谈Java值传递","url":"/从JVM堆栈的角度浅谈Java值传递.html","content":"\n一直没有搞清楚Java值传递究竟是什么意思，今天做《剑指Offer》第JZ40题时，给定了一个函数定义如`public void FindNumsAppearOnce(int[] array, int[] num1, int[] num2)`，需要将结果直接存入数组`num1`与`num2`中。很纳闷，为什么Java值传递的机制，可以将外部传入方法中的参数在方法内修改后，对外部可见呢？于是发誓一定要弄清楚Java值传递的概念，查阅了很多资料，做如下总结。\n\n## 一、JVM中的堆和栈\n要说清值传递，还得先从JVM中的内存模型说起。简单的说一说JVM中的**堆**和**栈**。\n\n- 堆内存：保存Java中的对象与数组（数组其实也是对象）。通过`new`出来的对象（实体）都保存在堆内存中，当实体失去引用后，该对象内存不会立马被释放，而是由JVM的GC定期回收。\n- 栈内存：保存Java中的局部变量（如定义在方法中的、for循环中声明的循环变量等），当变量离开作用域后，内存会立即被释放，故栈刷新速度很快。\n\n## 二、Java中的基本数据类型与引用类型\n```java\nint num = 10;\nString str = \"Fan\";\n```\n如上所示代码中，`num`是基本数据类型变量，其值`10`直接保存在变量内部；`str`是引用数据类型变量，其变量本身保存的是`\"Fan\"`在堆内存中的地址，故说`str`是字符串对象`\"Fan\"`的一个引用。\n\n## 三、为什么是值传递\n### 1. 情况1：数组与基本数据类型\n先定义下面两个方法：\n```java\npublic void changeArray(int[] num) {\n    num[0] = 1;\n}\n\npublic void changeInt(int num) {\n    num = 1;\n}\n```\n在方法外部定义如下两个变量并使用方法：\n```java\nint[] numArray = {5, 4, 3};\nint numInt = 5;\n\nchangeArray(numArray);\nchangeInt(numInt);\n```\n得到的结果是`numInt`依然是`5`，而`numArray`变成了`{1, 4, 3}`。导致这种结果的分析如下：\n- `numInt`传入`changeInt()`方法时，将自身（实参）的值拷贝了一份赋给形参`num`，在方法内部对形参的改变并不影响实参本身。\n- `numArray`传入`changeArray()`方法时，将自身（实参）保存的值（也就是指向数组`{5, 4, 3}`的地址）拷贝了一份赋给形参`num`，形参持有相同的地址。在方法内部对形参的改变直接作用于其指向的地址上，故实参也会发生改变。\n\n### 2. 情况2：字符串\n```java\nString str = \"Fan\";\nStringBuffer strBuf = \"Fan\";\n\npublic void changeString(String strChange) {\n    strChange = \"Jin\";\n}\n\npublic void changeStringBuffer(StringBuffer strBuffer) {\n    strBuffer.append(\" Jinpeng\");\n}\n\nchangeString(str);\nchangeStringBuffer(strBuf);\n```\n如上代码执行后的结果是，`str`依然为`\"Fan\"`，而`strBuf`变为了`\"Fan Jinpeng\"`。分析：\n- 在方法中，对字符串的重新赋值发生了`new`操作，即重新`new`了一个`\"Jin\"`对象，并由形参`strChange`指向该对象地址，此时`strChange`指向的地址已不再是由实参`str`拷贝来的地址了，所以不会影响到实参（`str`）保存的地址。\n- 而对于`StringBuffer`类型的对象，若在方法内部进行`append()`操作，形参`strBuffer`指向的地址没有改变，还是由实参拷贝进来的，所以实参也会发生变化。\n\n### 3. 情况3：对象\n```java\nclass Person {\n    String name;\n    // Constructer\n    // setter\n}\n\npublic void changeName(Person person) {\n    person.setName(\"Fan Jinpeng\");\n}\n\npublic void newChangeName(Person person) {\n    person = new Person();\n    person.setName(\"Spider Man\");\n}\n\nPerson fan = new Person();\nchangeName(fan);\nnewChangeName(fan);\n```\n如上代码执行后的结果是，`fan.name`被改为了`\"Fan Jinpeng\"`，而没有第二次被改变成`\"Spider Man\"`。分析：\n- `changeName()`方法将实参`fan`引用指向的对象地址拷贝了一份给形参`person`，方法内部的改动直接对该地址的指向，也即指向的对象进行修改（即对堆内存中存储的实体进行修改）。而`newChangeName()`方法内部将形参重新指向了一个新的`Person`对象，不再拥有拷贝来的地址，故对形参指向的对象的改动不会影响实参指向的对象。\n\n### 四、不严谨的说\n综上可以用不严谨的话来总结就是，Java是值传递，若方法传入的是对象，在方法内部对对象进行的直接修改是可以对外部发生改变的；然而若方法内部发生了`new`操作，即改变了形参的地址指向，那么方法内部的操作就是针对新的对象做出的变化，不会影响外部的对象。","tags":["Java","JVM"]},{"title":"并发基础汇总（持续更新……）","url":"/并发基础汇总（持续更新……）.html","content":"\n>参考资料：https://blog.csdn.net/cheidou123/article/details/90712178\n\n### 1. 进程和线程\n- **进程**：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在Java中，当启动main函数时其实就是启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程。\n- **线程**：线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\n- 区别：进程是系统进行资源分配的一个独立单位，线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，一个进程可以包括多个线程。\n- 线程的五个状态：\n    - 新建：创建线程还没有start\n    - 就绪：start但是还没有获取CPU时间片\n    - 运行：正在执行\n    - 阻塞：比如sleep等等状态\n    - 死亡：正常退出或者使其发生异常\n\n### 2. 线程的启动\n- 继承`Thread`类\n- 实现`Runnable`接口，规定`run()`方法，该方法不能抛出异常。\n- 实现`Callable`接口，规定`call()`方法，`Callable`的任务执行后可返回值，此时需要调用`FutureTask.get()`方法实现，此方法会阻塞主线程直到获取**将来**结果；当不调用此方法时，主线程不会阻塞。该方法可以抛出异常。\n\n### 3. 停止线程\n- `stop()`方法强行终止线程（不推荐的方法）；\n- 使用退出标志（推荐）；\n- 使用`interrupt()`方法中断线程（该方法并不能真正中断线程，需要其他方式配合）。\n\n### 4. Sleep\n- 必须捕获异常；\n- 线程睡眠到期自动苏醒，并返回到可运行状态（就绪），而非运行状态。\n- `sleep()`没有释放锁。\n\n### 5. Wait/Notify/NotifyAll\n三者都需要在同步方法或者同步代码块调用，否则抛出`java.lang.IllegalMonitorStateException`运行异常。\n- 进入`wait()`后，当前线程释放锁；\n- `notify()`唤醒一个正在等待该对象的线程，然后竞争获取锁；\n- `notifyAll()`唤醒所有正在等待该对象的线程，然后竞争获取锁。\n\n### 6. Yield\n`yield()`使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。CPU会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到。\n\n### 7. Join\n`join()`主要作用是同步，使得线程之间的并行执行改变为串行。参数可以传入等待时间，若缺省或为0则等待执行完毕。\n\n### 8. 线程优先级\n优先级高的线程获得的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。\n- 线程的优先级用`thread.setPriority(int a)`来设置，a取值范围为0-10，默认为5。\n- 线程优先级有继承性，如果主线程启动`threadA`线程且`threadA`线程没有另外赋予优先级，则`threadA`线程优先级和`main`线程一样（即通过A线程启动线程B，线程B没有设置优先级则优先级同A一致）。\n- CPU尽量将执行资源让给线程优先级高的，即线程优先级高的总是会大部分先执行，但是不代表高优先级的线程全部都先执行完再执行低优先级的线。\n- 优先级在调用`start()`之前进行设置。\n\n### 9. 内存可见性\n**（1）JVM**\n一个线程对共享变量值的修改能够及时被其它线程看到，则把这个共享变量叫做可见的。\n- 所有变量都存储在主内存中；\n- 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本。\n\nJava内存模型的规定：\n- 线程对共享变量的所有操作必须在自己的工作内存中进行，不能直接从主内存中读写。\n- 线程间变量值传递必须通过主内存。\n\n如果线程1对共享变量的操作希望线程2看到，需要如下两个步骤：\n- 将共享变量刷新到主内存，\n- 更新到线程2工作内存。\n\n**（2）Synchronized**\n- `sychronized`关键字可以实现原子性和可见性；\n- 加锁时清空工作内存共享变量的值，使用共享变量从主内存读取最新的值。\n\n**（3）Volatile**\n- `volatile`关键字只能保证可见性，不能保证原子性。\n\n### 10. 死锁\n**（1）产生死锁必须具备以下四个条件**\n- **互斥条件**：该资源任意一个时刻只由一个线程占用；\n- **请求与保持条件**：一个线程因请求资源而阻塞时，对已经持有的资源保持不放；\n- **不剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕才释放资源；\n- **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n**（2）如何避免死锁的产生**\n只需要破坏四个条件之一即可：\n- **破坏互斥条件**：无法达到，因为加锁的目的就是形成互斥。\n- **破坏请求与保持条件**：一次性申请所有的资源。\n- **破坏不剥夺条件**：占用资源的线程进一步申请其他资源时，若申请不到，则可以主动释放自己占用的资源。\n- **破坏循环等待条件**：靠按序申请资源预防。按某一顺序申请资源，释放资源时反序释放。\n\n### 11. 守护线程\nJava中的两种线程分别是**用户线程**与**守护线程**，守护线程是最低优先级（如垃圾回收线程）。\n\n### 12. `sychronized`关键字\n**（1）原理**\n- **代码块同步**：使用`monitorenter`和`monitorexit`指令实现，`monitorenter`是在编译后插入到同步代码块的开始位置，`monitorexit`插入到同步代码块的结束处和异常处。任何对象都有一个monitor与之关联，当一个monitor被持有后，它将处于锁定状态。根据虚拟机规范的要求，在执行`monitorenter`指令时，首先要去尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1；相应地，在执行`monitorexit`指令时会将锁计数器减1，当计数器被减到0时，锁就释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。\n- **方法同步**：相对于普通方法，其常量池中多了*ACC_SYNCHRONIZED*标示符。JVM就是根据该标示符来实现方法的同步的，当方法调用时，调用指令将会检查方法的*ACC_SYNCHRONIZED*访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。本质上和代码块同步没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。\n\n**（2）注意事项**\n- `sychronized`获取的都是对象锁；\n- A线程持有object对象的Lock锁，B线程可以调用object对象的非`synchronized`方法，但不可以调用object任何的`synchronized`方法；\n- `sychronized`是可重入锁；\n- 若出现异常，锁将会自动释放；\n- `static`方法加`synchronized`是属于类的，非`static`方法是属于对象的。\n\n### 13. ReentrantLock\n**（1）概述**\n`sychronized`局限性：\n- 当线程尝试获取锁时，如果获取不到会一直阻塞；\n- 如果获取锁的线程进入休眠或阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等到。\n\n**（2）锁的基本概念**\n- **可重入锁**：如果当前线程已经获得了某个监视器对象所持有的锁，那么该线程在该方法中调用另外一个同步方法也同样持有该锁。也可以这样说：同一个线程可以多次获取同一把锁。`ReentrantLock`和`synchronized`都是可重入锁。\n- **可中断锁**：如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。\n- **公平锁**：先到先得。\n\n**（3）ReentrantLock与sychronized关键字对比**\n- 都是可重入锁。\n- `sychronized`是关键字，`ReentrantLock`是类。\n- `sychronized`通过JVM字节码实现，`ReentrantLock`通过CAS实现。\n- `synchronized`的加锁和释放锁是自动的，`ReetrantLock`需要手动加锁和释放锁。\n- `synchronized`是不可中断的，`ReetrantLock`可中断的。\n- `ReenTrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。\n- `ReetrantLock`的`tryLock`可以设置超时机制。\n\n### 14. `volatile`关键字\n**（1）目的**\n保证变量的内存可见性，防止局部重排列。\n\n**（2）原理**\n`volatile`关键字增加内存屏障（内存栅栏），可以提供以下功能：\n- 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。\n- 它会强制将对缓存的修改操作立即写入主存。\n- 如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n**（3）与sychronized的区别**\n- `volatile`只能修饰变量，性能好。`synchronized`可以修饰代码块，方法。\n- `volatile`不会出现阻塞，`synchronized`会出现阻塞。\n- `volatile`保持数据可见性，不支持原子性，`synchronized`保证原子性，也间接保证可见性。\n- `volatile`解决的是变量在多个线程之间的可见性，而`synchronized`关键字解决的是多个线程访问资源的同步性。\n\n### 15. 线程池\n**（1）目的**\n- 避免创建和销毁线程的系统开销；\n- 控制最大并发数，防止阻塞；\n- 对线程进行简单管理，如延迟执行。\n\n**（2）使用原理**\n- 线程数量未达到corePoolSize，则新建一个线程（核心线程）执行任务；\n- 线程数量达到了corePoolSize，则将任务移入队列等待；\n- 队列已满，新建线程（非核心线程）执行任务；\n- 队列已满，且总线程数已达到maximumPoolSize，则会采取拒绝策略。\n\n**（3）常见线程池**\n- 可缓存线程池`CachedThreadPool`：\n    - 线程数无限制；\n    - 有空闲线程则复用空闲线程，无空闲线程则新建线程；\n    - 闲置线程60s会自动销毁。\n- 定长线程池`FixedThreadPool`：核心线程数=最大线程数，并且池内线程不会因为闲置超时而销毁，队列无限长，直到outOfMemory。\n- 定时线程池`ScheduledThreadPool`：\n    - 设置核心线程数，最大线程数为Integer.MAX_VALUE，其实也是无限长；\n    - 支持延迟及周期性任务执行。\n- 单线程化线程池`SingleThreadPool`：有且仅有一个工作线程执行任务，所有任务按序执行，遵循队列规则。","tags":["Java","多线程"]},{"title":"Java基础汇总（持续更新……）","url":"/Java基础汇总（持续更新……）.html","content":"\n>参考资料：https://blog.csdn.net/cheidou123/article/details/95041367\n\n### 1. Java重载、重写与隐藏\n- 重载（overload）：类中多态性的表现。\n    - 根据方法参数列表中的参数类型或参数个数；\n    - 不可以基于方法的返回值类型。\n- 重写（override）：\n    - “两小”：子类方法的返回值类型、抛出的异常均小于父类方法的；\n    - “两同”：子类方法的方法名和参数列表均与父类方法的相同；\n    - “一大”：子类方法的访问权限应大于父类方法的。\n- 隐藏：针对父类的成员变量或静态方法。\n    - 子类声明了与父类相同的变量时，父类的同名变量被隐藏；\n    - 子类声明了与父类同名的静态方法、且方法的参数列表与返回值类型均与父类方法相同时，父类的同名静态方法被隐藏。\n\n### 2. 构造方法\n- 与类名相同；\n- 没有返回类型，也不能为`void`；\n- 完成对象的初始化工作，将定义对象时的参数传递给对象的域；\n- 一个类可以定义多个构造方法，若不定义，则会自动生成一个无参数的构造方法，且方法内不执行任何代码；\n- 可以根据参数列表中参数的类型、个数、顺序对构造方法重载；\n- 不能被`static`、`final`、`synchronized`、`abstract`、`native`修饰，但可以被`private`、`protected`、`public`修饰；\n- 不能被继承，只能被显式或隐式的调用；\n- 若父类没有无参的构造方法，则子类需在自己的构造方法中显式地调用父类的构造方法；\n- 构造方法每次都是构造新的对象，不存在多个线程同时读写同一个对象中属性的问题，所以不需要同步。\n\n### 3. 访问修饰符\n- `public`：当前类、子类、包内、其他包；\n- `protected`：当前类、子类、包内；\n- `default`：当前类、包内；\n- `private`：当前类。\n- `private`的属性和方法可以被子类继承，但不能被子类调用。\n\n### 4. 接口、抽象类及它们的联系与区别\n- 抽象类\n    - 不能被实例化；\n    - 抽象方法必须由子类重写，若未被子类重写，则子类也是抽象类；\n    - 只要包含一个抽象方法就是抽象类；\n    - 抽象类中可以包含具体方法，也可以不包含抽象方法；\n    - 子类中的抽象方法不能与父类中同名；\n    - `abstract`和`final`不能并列修饰同一个类；\n    - `abstract`不能与`private`、`static`、`final`、`native`并列修饰同一个方法。\n\n- 接口\n    - 一个类可以实现多个接口（实现多继承）；\n    - 接口中的常量和方法必须是`public`的；\n    - 在接口中只有方法的声明，没有方法体；\n    - 接口中所有方法都必须是抽象的，可以在接口中定义数据成员，但必须是常量；\n    - 接口中没有构造方法，也不能实例化出接口的对象；\n    - 接口中的方法需要由实现类实现，若实现类不去实现接口中所有的方法，则该类需被定义为抽象类；\n    - 接口中不能包含静态方法。\n\n- 联系\n    - 都不能被实例化；\n    - 都可以包含抽象方法。\n\n- 区别\n    - 一个子类只能继承一个抽象类，但可以实现多个接口；\n    - 抽象类可以有构造方法，但接口不能；\n    - 抽象类可以有普通成员变量，但接口不能；\n    - 抽象类和接口都可以有静态成员变量，抽象类中静态成员变量可以是任意访问类型，接口只能为`public static final`；\n    - 抽象类可以没有抽象方法，抽象类可以有普通方法，Java8之前，接口中的方法都为抽象方法，Java8之后，接口中可以有默认方法；\n    - 抽象类可以有静态方法，接口不能；\n    - 抽象类中方法可以被`public`或`protected`修饰，接口中只能由`public`修饰，Java9接口可以定义私有方法，但不能是抽象的。\n\n### 5. 析构函数\n与**构造函数**相反，析构函数用于在对象结束其生命周期时，系统自动调用进行完成“清理善后”工作（如建立对象时使用`new`开辟了一片内存空间，退出前应在析构函数中使用`delete`释放）。\n\n### 6. JDK中常用的包与功能\n- java.lang：提供使用Java编程语言进行程序设计的基础类；\n- java.util：提供各种实用功能类，如Collection框架、遗留的Collection类、事件模型、日期和时间、国际化、字符串标记生成器、随机数生成器、位数组等；\n- java.awt：抽象窗口工具包，用于编写GUI程序；\n- java.swing：轻量级窗口工具包，现最广泛使用的GUI程序设计包；\n- java.io：提供系统的输入输出类和接口，只要包括输入流类`InputStream`和输出流类`OutputStream`就可以实现文件的输入输出、管道的数据传输以及网络数据传输的功能；\n- java.net：提供实现网络应用程序的类，包括用于实现Socket通信的`Socket`类以及便于处理URL的类等；\n- java.sql：提供使用Java编程语言访问并处理存储在数据源（通常是一个关系数据库）中的数据的 API。\n\n### 7. `super`和`this`关键字\n- `this`表示当前对象，即当前类对象，`super`表示当前类的父类对象；\n- `this()`和`super()`需放在构造函数第一行；\n- 都是对象，所以不能在static环境中使用；\n- `this()`和`super()`不能在同一个构造函数内使用。\n\n### 8. `Object`类的基本方法\n- `clone()`：实现对对象的浅复制，需实现`Cloneable`接口才可调用该方法，否则抛出`CloneNotSupportedException`。\n- `getClass()`：`final`方法，获得运行时类型。\n- `toString()`：返回对象的字符串表示。\n- `finalize()`：用于资源释放，无法确定该方法何时被调用。\n- `equals()`：注意与`==`的区别（[equals()与==的区别](https://snailclimb.gitee.io/javaguide/#/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=128-%e5%92%8cequals%e7%9a%84%e5%8c%ba%e5%88%ab)）。\n- `hashCode()`：用于哈希查找（[hashCode()与equals()的区别](https://snailclimb.gitee.io/javaguide/#/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=129-hashcode%e4%b8%8e-equals)）。\n- `wait()`：使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，即具有该对象的锁。`wait()`一直等待直到获得锁或者被中断。`wait(long timeout)`设定一个超时间隔，若超时内未获得锁就返回。调用该方法后当前线程进入睡眠状态，直到发生下列事件：\n    - 其他线程调用了该对象的`notify()`；\n    - 其他线程调用了该对象的`notifyAll()`；\n    - 其他线程调用`interrupt()`中断该线程，此时抛出`InterruptedException`异常；\n    - 超时。\n- `notify()`：唤醒在该对象上等待的某个线程。\n- `notifyAll()`：唤醒在该对象上等待的所有线程。\n\n### 9. `final`关键字\n- 用于修饰类、方法、属性，但不可修饰抽象类，因为抽象类一般需要被继承，`final`修饰的类无法被继承；\n- 修饰的方法不能被重写（override）；\n- 修饰的属性会变为常量，无法被再赋值。\n\n### 10. J2EE常见名词\n- EJB：Enterprise Java Bean；\n- JNDI：Java Naming & Directory Interface，Java命名目录服务；\n- JMS：Java Message Service，Java消息服务；\n- JTA：Java Transaction API，Java事务服务；\n- JAF：Java Action Framework，Java安全认证框架。\n\n### 11. 加载驱动的三种方式\n- `Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\")`；\n- `DriverManager.registerDriver(new com.mysql.jdbc.Driver())`;\n- `System.setProperty(\"jdbc.drivers\", \"com.mysql.jdbc.Driver\")`。\n\n### 12. 静态方法、静态变量、静态代码块\n- **静态方法**不能引用非静态方法和非静态属性，因为静态方法不需要经过实例化就可以使用；\n- 静态方法中没有`this`指针；\n- 静态方法可以被重载；\n- 静态方法在装载class时首先完成，比构造方法早，此时非静态方法还没有完成初始化，因此无法被调用。\n- **静态代码块**优先于主方法，且只执行一次。\n- 只有类才存在**静态变量**，非静态方法可以调用静态变量，但不能在方法内定义静态变量。\n\n### 13. Java表达式转型规则\n由低到高转换：`byte` -> `short`(`char`) -> `int` -> `long` -> `float` -> `double`\n\n### 14. 基本数据类型和引用数据类型\n基本类型（原生类）只能保存一些常量数据；而引用类型除了可以保存数据，还可以提供操作这些数据的功能。为了操作基本数据类型，Java对它们进行了封装，将8中基本数据类型包装为包装类。\n- 引用类型包括类、接口、数组和特殊的null类型；\n- 引用数据类型的变量名指向存储数据对象的内存地址，即变量名指向hash值。\n\n### 15. Java变量初始值问题\n类的成员变量有初始值，局部变量没有初始值，`final`修饰的变量一定要有初始值。\n\n### 16. Java的四种引用\n- 强引用：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。\n- 软引用：内存不足回收。可以用来做缓存。\n- 弱引用：无论内存是否充足，都会回收被弱引用关联的对象，弱引用能用来在回调函数中防止内存泄露。因为回调函数往往是匿名内部类，隐式保存有对外部类的引用，所以如果回调函数是在另一个线程里面被回调，而这时如果需要回收外部类，那么就会内存泄露，因为匿名内部类保存有对外部类的强引用。\n- 虚引用：它并不影响对象的生命周期。在Java中用`java.lang.ref.PhantomReference`类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。\n\n### 17. Java序列化\n- 序列化：把Java对象转换成字节序列；\n- 反序列化：把字节序列转换成Java对象。\n- 序列化的作用：\n    - （1）实现数据持久化，通过序列化可以把数据永久存储在磁盘中；\n    - （2）利用序列化实现远程通信，即在网络上传送对象的字节序列。\n- 注意事项：\n    - `transient`修饰的变量在序列化之后对应的值没了；\n    - 不能序列化`static`变量，静态变量属于类，保存的是类的状态；\n    - 需要加上序列化ID。\n\n### 18. 类型转换\n- 自动类型转换：目标类型大于原类型，如`int`可以直接赋值给`double`型。\n- 强制类型转换：目标类型小于原类型，将对于的小数位截断。\n- 类型提升：当一个Java算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将发生自动提升：\n    - 所有`byte`型、`short`型和`char`型将被提升到int型；\n    - 整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型。\n\n```java\nbyte b1 = 3, b2 = 4, b3;\nb3 = (b1 + b2); // 编译不通过，b1+b2被自动提升为int型，b3为byte型，若要赋值需要进行强转。\n```\n\n### 19. 多态\n（1）多态的作用\n- 一个接口，多种实现，通过抽象化来提高程序的扩展性。\n\n（2）多态的条件\n- 有继承关系；\n- 子类要重写父类的方法；\n- 父类引用指向子类。\n\n（3）多态的注意事项\n- 多态后不能使用子类特有的属性和方法；\n- 成员变量和静态方法使用父类的；\n- 子类重写的普通方法使用子类的。\n\n（4）基于JVM解释多态\n\n方法调用是依照方法的符号引用得到具体内存引用的过程。调用类的方法（静态方法）在类加载时就直接转化为具体内存引用，为静态绑定；调用对象的方法则是动态绑定，最后得到真正的方法引用，完成调用。\n\n### 20. 数组\n- 数组是引用类型，不属于原生类，可以看成是一种对象，一旦指定了大小就无法改变。\n- 数组的初始化：\n    - 左边的名称和括号顺序可以颠倒（如`int[] a`和`int a[]`），但右边的第一个括号内一定要有值；\n    - 定义数组，左边的括号内不能有值，即数组的大小定义放在右边。\n- 对于多维数组，`array.length`取的是最外层括号包含的元素个数。\n- 数组的四种拷贝方式效率对比：`System.arraycopy` > `clone` > `Arrays.copyOf` > `for`。\n\n### 21. `Comparable`和`Comparator`的区别\n- `Comparable`内部比较器：若一个类实现了`Comparable`接口，则意味着该类支持排序。实现该接口的类的对象的列表或数组可以通过`Collections.sort()`或`Arrays.sort()`进行自动排序，一般要重写`compareTo()`方法；\n- `Comparator`外部比较器：位于`java.util`包下，`Comparator`是比较接口。若需要控制某个类的次序，而该类本身不支持排序（即没有实现`Comparable`），则可以通过建立一个“该类的比较器”进行排序，这个比较器只需实现`Comparator`接口，一般要重写`compare()`方法。\n\n### 22. 类的生命周期以及双亲委托机制\n生命周期：加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载\n\n**（1）加载**\n\n整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。\n\n**双亲委托机制**：Java的类加载使用双亲委派模式，即一个类加载器在加载类时，先把这个请求委托给自己的父类加载器去执行，如果父类加载器还存在父类加载器，就继续向上委托，直到顶层的启动类加载器。如果父类加载器能够完成类加载，就成功返回，如果父类加载器无法完成加载，那么子加载器才会尝试自己去加载。\n\n- 启动类加载器（Bootstrap ClassLoader），JVM的一部分，负责将放置在`Jre\\lib`目录中或者被`-Xbootclasspath`参数所指定路径中的，并且是虚拟机能识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接使用。\n- 扩展类加载器（Extension ClassLoader），这个类加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载`Jre\\lib\\ext`目录中或者被`java.ext.dirs`系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。\n- 应用程序类加载器（Application ClassLoader），负责加载`ClassPath`所有jar或目录，开发者可以直接使用这个类加载器。\n- 自定义加载器\n\n**（2）验证**\n\n验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求。\n\n**（3）准备**\n\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。\n- 这里内存分配只是类变量（`static`修饰的），而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中。\n- 为类变量赋值为0值（0、0L、null、false等）。\n- 例如`public static int value = 3;`，准备阶段会将`value`赋值为0，直到初始化阶段才将其赋值为3；若被`final`修饰，则直接赋值为3。\n\n**（4）解析**\n\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。\n\n**（5）初始化**\n\n初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。\n\n**（6）使用**\n\n使用该类所提供的功能，其中包括主动引用和被动引用。\n- 主动引用\n    - 通过`new`关键字实例化对象，读取或设置类的静态变量，调用类的静态方法。\n    - 通过反射方式执行上述三种行为。\n    - 初始化子类时会触发父类的初始化。\n    - 作为程序入口直接运行时（直接调用main方法）。\n- 被动引用\n    - 引用父类的非`final`静态变量，只会引起父类初始化，不会引起子类初始化。\n    - 引用父类的`final`静态变量，父类子类都不会初始化。\n    - 定义类数组不会引起类的初始化。\n    - 引用类的常量不会引起类的初始化。\n\n**（7）卸载**\n\n在使用完类后，若满足以下条件，就会被卸载。\n- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；\n- 加载该类的ClassLoader已经被回收；\n- 该类对应的`java.lang.Class`对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n若上述三个条件全部满足，JVM就会在方法区垃圾回收的时候对类进行卸载，即在方法区中清空类信息，结束Java类的生命周期。\n\n### 23. 动态绑定和静态绑定\n- **绑定**的概念：一个方法的调用与所在的类（方法的主体）关联起来。\n- **静态绑定**：在编译过程中就知道该方法是哪个类中的方法，只有`final`、`static`（重写`static`方法使用多态，调用的仍然是父类的`static`方法）、`private`和构造方法使用静态绑定。\n- **动态绑定**：在运行时绑定。**原理**：父类不是接口，当子类和父类加载到虚拟机时，方法区就有了类的信息，方法区中有方法表，如果子类重写父类的方法，那么在各自方法表里方法的偏移量是一样的，当我们调用时，\n    - 先找到方法调用的符号引用，\n    - 查看父类偏移量，\n    - 找到具体子类，\n    - 根据父类偏移量查看子类方法表有没有重写。\n\n如果父类是接口的话，无法根据偏移量来确定，则采用搜索方法表的形式，效率要低些。\n\n### 24. HashMap\n（1）基本结构\n- 构造函数\n```java\n// 默认构造函数\nHashMap() // 默认大小为16\n\n// 指定容量大小\nHashMap(int capacity) // capacity必须是2的次幂，从而减少碰撞\n\n// 指定容量大小和加载因子\nHashMap(int capacity, float loadFactor) // loadFactor默认值是0.75\n\n// 包含 子Map 的构造函数\nHashMap(Map<? extends K, ? extends V> map)\n```\n\n- 基本结构\n    - jdk1.7：数组+链表（头插）\n    - jdk1.8：数组+链表（尾插）/红黑树（链表长度到8时，将链表转换成红黑树来处理）\n\n（2）存取元素\n- 存元素：HashMap会对`key`值为null的进行特殊处理，总是放到`table[0]`位置。`put()`过程是先计算哈希值然后通过哈希值与`table.length`取模计算index值，然后将key放到`table[index]`位置，当`table[index]`已存在其它元素时，会在`table[index]`位置生成一个链表，将新添加的元素放在`table[index]`（头插），原来的元素连接到`Entry.next`，这样以链表形式解决哈希冲突问题，当元素数量达到临界值时，则进行扩容，使table数组长度变为原来的两倍。jdk1.8版本中，链表改为尾插，且当长度超过8时转换为红黑树。\n- 取元素：同样当`key`为null时会进行特殊处理，在`table[0]`的链表上查找key为null的元素。`get()`的过程是先计算哈希值然后通过哈希值与`table.length`取模计算index值，然后从`table[index]`上的链表或红黑树找到key，然后返回。","tags":["Java"]},{"title":"Ubuntu16环境下部署Cbench测试工具","url":"/Ubuntu16环境下部署Cbench测试工具.html","content":"\n>哦，天啊，SDN实验，永远滴痛。\n\n今天折腾SDN的实验，使用SDN的Controller Benchmark测试工具Cbench来测试SDN控制器的性能。众所周知（也许只我一菜逼知道），由于一些文档的缺乏，加上各种工具版本的更迭导致的各工具之间不兼容问题，SDN的实验环境极其难以部署（吧）。今天在Ubuntu16.04LTS环境下搭建了该测试环境，费了不少功夫，不过也算是完成了。\n\n## 实验环境\n- 操作系统：Ubuntu16.04LTS\n- SDN控制器：Floodlight（github master）最新版（https://github.com/floodlight/floodlight）\n- 测试工具：Cbench（https://github.com/mininet/oflops）\n- OpenFlow：1.0（https://github.com/mininet/openflow）\n\n## 搭建步骤\n### 一. 安装Floodlight控制器\n#### 1. 安装jdk8\n\n由于最新版Floodlight控制器依赖Java8版本，所以操作系统中需要配置jdk8环境。\n\n我一开始使用命令行安装的openjdk-1.8，但是导致Floodlight安装过程出现了问题，所以从jdk官网下载了jdk1.8，通过.bashrc配置系统变量，解决了Floodlight安装错误问题。\n\n- 从oracle官网下载jdk1.8-linux-x64版\n```text\n我下载的版本是 jdk-8u251-linux-x64.tar.gz\n```\n- 解压到/opt/java文件夹中（这里其实可以随意，只要后面配对系统环境变量就行）\n```shell\nsudo tar -zxvf jdk-8u251-linux-x64.tar.gz -C /opt/java/\n```\n- 配置环境变量，在`~/.bashrc`中添加下列两行\n```shell\n# cd ~\n# vim .bashrc\n```\n```\nexport JAVA_HOME=/opt/java/jdk1.8.0_251\nexport PATH=${JAVA_HOME}/bin:${PATH}\n```\n- 使`.bashrc`生效\n```shell\nsource ~/.bashrc\n```\n\n#### 2. 安装Floodlight控制器\n- 安装依赖\n```shell\n# sudo apt-get install build-essential ant maven python-dev\n```\n- 进入`~`目录\n- 操作如下\n```shell\n# git clone git://github.com/floodlight/floodlight.git\n# cd floodlight\n# git submodule init\n# git submodule update\n# ant\n\n# sudo mkdir /var/lib/floodlight\n# sudo chmod 777 /var/lib/floodlight\n```\n\n### 二. 安装OpenFlow\n- 进入`~`目录\n- 操作如下\n```shell\n# git clone git://github.com/mininet/openflow.git\n```\n- 这里得到OpenFlow的目录是你用户目录下的`openflow`目录，等会需要用到，直接进入该目录输入`pwd`即可获取完整绝对路径\n\n### 三. 安装Cbench\n- 安装必要的依赖\n```shell\n# sudo apt-get install autoconf automake libtool libpcap-dev\n```\n- 注意这里我没有按照官网上安装`libsnmp-dev`，因为我安装的时候出错了。用如下方法安装：（aptitude可以帮助你安装需要的依赖，或者帮助你选择降级部分依赖来使得能够正确安装与使用）\n```shell\n# sudo apt-get install aptitude\n# sudo aptitude install libsnmp-dev\n```\n- 安装Cbench，在`~`目录下，这里的`/home/funny/openflow`是我之前OpenFlow安装的目录\n```shell\n# git clone git://github.com/mininet/oflops.git\n# cd oflops/\n# sh boot.sh\n# ./configure --with-openflow-src-dir=/home/funny/openflow\n# make\n# sudo make install\n```\n- 如果在`make`过程中出现`libconfig.h: No such file or directory`的错误，则安装`libconfig-dev`\n```shell\n# sudo apt-get install libconfig-dev\n```\n\n至此，Cbench就完整的安装完成了。开始做实验吧（哭脸）~","tags":["SDN"]},{"title":"关于finally子句是否总是一定执行的问题","url":"/关于finally子句是否总是一定执行的问题.html","content":"\n之前在牛客上看到一道面试题，是关于“finally子句是否总是一定会被执行”。在初学Java异常章节的时候，学习到`try-catch-finally`的语句，说明了`finally`子句的用途是用于确保安全的回收资源等，因此`finally`子句总是会被系统执行。而学习到并发章节的时候，找到了一个特例。章节内容见`《Java编程思想》第21章-21.2.8-后台线程`。\n\n如下一段代码：\n```java\nclass ADaemon implements Runnable {\n    @Override\n    public void run() {\n        try {\n            System.out.println(\"Starting ADaemon\");\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            System.out.println(\"Existing via InterruptedException\");\n        } finally {\n            System.out.println(\"This should always run?\");\n        }\n    }\n}\n\npublic class DaemonsDontRunFinally {\n    public static void main(String[] atgs) throws Exception {\n        Thread t = new Thread(new ADaemon());\n        t.setDaemon(true);\n        t.start();\n    }\n}\n\n/* Output:\nStarting ADaemon\n*///:~\n```\n\n由于线程`t`被注册为后台线程，因此当执行该程序后，`finally`子句将不会得到执行，除非注释掉`setDaemon()`的调用。结合书中所述，由于非后台线程`main()`被终止时，后台线程会“**突然**”终止，即JVM会在`main()`退出后立即关闭所有后台进程，而不会有任何被希望出现的确认形式。故在这种情况下，`finally`子句将无法被执行。\n\n>2020.8.23更新，摘自《Java并发编程的艺术》\n\n当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。因此在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。\n\n---\n\n在牛客的面试题中，一条回答表示“当在finally子句前调用System.exit(0)”时，`finally`子句就不会被执行。即如上后台线程示例的情况一致，由于在`main()`线程中退出，其退出动作发生在`run()`中的`finally`子句之前，故`finally`子句将不会被执行。\n\n关于这个问题涉及到JVM的运行机制以及线程等问题，在此先留题占坑，等待后续学习到更加清晰的原因时再来补充解释。（2020.5.25）","tags":["Java"]},{"title":"简单说Java中接口和抽象类的区别","url":"/简单说Java中接口和抽象类的区别.html","content":"\n>本文参考自——牛客题库-Java校招面试题汇总\n\n### 从定义上说\n- 接口中所有的方法隐含的都是抽象的；而抽象类则可以同时包含抽象和非抽象的方法。\n- Java中只支持单继承。对于接口来说，类可以实现多个接口；但只能继承自一个抽象类。\n- 接口中声明的变量（成员属性）都是`final`的；而抽象类可以包含`非final`的变量（成员属性）。\n- 接口中的成员函数（成员方法）默认是`public`的；而抽象类的成员函数（成员方法）可以是`private`、`protected`和`public`。\n- 接口是绝对抽象的，不可以被实例化；抽象类也不可以被实例化。\n- 类可以不实现抽象类和接口中声明的所有方法，但在此情况下，该类必须得声明为抽象类。\n- 基于上一条，抽象类可以在不提供接口方法实现的情况下实现接口。即，普通类实现了一个接口，则必须给出该接口内所有方法的具体实现；而抽象类实现接口，可以不在该抽象类内部给出接口中方法的实现，但若某普通类继承自该抽象类，必须给出该接口中所有方法的具体实现。代码如下：\n```java\ninterface A {\n    void f();\n}\n\nabstract class B implements A {\n    public abstract void g();\n}\n\npublic class C extends B {\n    /**\n    * 这里的f()方法必须被声明为public的，因为接口中的方法签名默认为public\n    */\n    @Override\n    public void f() {\n        ...\n    }\n\n    /**\n    * 这里g()方法的访问权限不能小于原方法签名所声明的权限，如原方法声明为public，这里就不能使用protected等public以下的关键字修饰\n    */\n    @Override\n    public void g() {\n        ...\n    }\n}\n```\n\n### 从设计层面来说\n- 抽象类是对类的抽象，是一种模板设计。\n- 接口是对行为的抽象，是一种行为的规范。","tags":["Java"]},{"title":"Java链表操作中易犯的错误","url":"/Java链表操作中易犯的错误.html","content":"\n今天刷《剑指offer》中的链表操作的题目，在一处曾经经常出错的位置再一次犯了错误，该错误为在一个自定义的链表中，遍历链表节点的过程中，由于错误的判断语句导致的死循环。具体代码如下：\n\n```java\n/**\n* 链表节点的定义\n*/\nclass Node {\n    int val;\n    Node next;\n\n    Node(int val) {\n        this.val = val;\n    }\n}\n\n/**\n* 遍历链表的操作\n*/\npublic class LinkedList {\n    public void iterateNode(Node node) {\n        while (node != null) {\n            System.out.print(node.val + \" \");\n            if (node.next != null) { // 错误发生在此处，由于加入判断下一个节点不为空，才将next指针向后移动，所以当遍历到链表的最后一个节点时，它的下一个节点必为null，于是指针不向后移动，当前节点永不为null，发生死循环\n                node = node.next;\n            }\n        }\n    }\n}\n```\n\n其实如上代码中的遍历中，`if (node.next != null)`不仅是多余的语句，而且也是错误的语句。因为在节点初始化的过程中，`next`成员会被初始化为`null`，故在`while (node != null)`的循环判断中，可以直接判断当前节点是否为空。若遍历到链表中最后一个节点时，它的下一个节点为空节点，可以直接执行`node = node.next`来将指针后移，在下一次`while`判断后不进入循环即可正常运行。修改后的代码如下：\n\n```java\npublic void iterateNode(Node node) {\n    while (node != null) {\n        System.out.print(node.val + \" \");\n        node = node.next;\n    }\n}\n```","tags":["Java","数据结构"]},{"title":"一份代码搞清楚内部类","url":"/一份代码搞清楚内部类.html","content":"\n最近学习神书《Java编程思想》，学习到第10章内部类的内容时，花了很久时间消化。现在基本搞懂了一些基本，用一份代码大致上总结了全章大部分内容。\n\n解释说明全部在代码中用注释标识，以供理解。\n\n```java\npackage com.blackside.chapter_10;\n\ninterface Counter {\n    int next();\n}\n\npublic class TestForInnerClass {\n    private String name = \"OuterClass\";\n    private int testCount;\n\n    private class InnerClass {\n        private String name = \"InnerClass\";\n\n        /**\n         * 当内部类与外围类具有相同名的成员属性时，如何区分？\n         * 内部类中，用this标识符指代内部类自己，用 外围类名.this 指代外围类\n         * @return\n         */\n        // 操作内部类的成员属性\n        public String returnInnerName() {\n            return this.name;\n        }\n\n        // 操作外围类的成员属性\n        public String returnOuterName() {\n            return TestForInnerClass.this.name;\n        }\n    }\n\n    /**\n     * 局部内部类\n     * 可以拥有构造器\n     * 局部内部类对象，对其外围类来说可以拥有多个，即内部类可以复用\n     * @param givenName\n     * @return\n     */\n    public Counter[] getLocalInnerClass(final String givenName) {\n        Counter[] counters = new Counter[2];\n\n        class LocalInnerClass implements Counter {\n            private String name = \"LocalInner\";\n            private int number;\n\n            // 局部内部类的构造器\n            public LocalInnerClass(int number) {\n                /**\n                 * 这里形参不允许被修改，则说明局部内部类的形参需要被定义为final\n                 */\n                this.number = number;\n//                givenName += \"Testing\";\n                System.out.println(\"I am LocalInnerClass \" + this.number + \".\");\n            }\n\n            @Override\n            public int next() {\n                System.out.print(TestForInnerClass.this.name + name + \" \" + givenName + \" \" + this.number + \" output \");\n                return testCount++;\n            }\n        }\n        // 这里，不匿名的局部内部类得到复用，可以创建多个该内部类的对象\n        counters[0] = new LocalInnerClass(1);\n        counters[1] = new LocalInnerClass(2);\n        return counters;\n    }\n\n    /**\n     * 匿名内部类\n     * 无法拥有构造器，但可以使用实例初始化的方式\n     * 匿名内部类对象对于其外围类，只能拥有一个，匿名内部类无法使用多次\n     * @param givenName\n     * @return\n     */\n    public Counter getAnonymousInner(final String givenName) {\n        // 返回的匿名内部类对象一次性返回，且只产生一个对象，无法复用\n        return new Counter() {\n            private String name = \"LocalAnonymousClass\";\n\n            // 匿名内部类无法拥有构造器，这里使用实例初始化的方式\n            {\n                /**\n                 * 这里形参不允许被修改，则说明局部内部类的形参需要被定义为final\n                 */\n//                givenName += \"Testing\";\n                System.out.println(\"I am LocalAnonymousInnerClass.\"); // 匿名内部类无法拥有构造器，可以使用实例初始化的方式\n            }\n\n            @Override\n            public int next() {\n                System.out.print(TestForInnerClass.this.name + \" \" + name + \" \" + givenName + \" output \");\n                return testCount++;\n            }\n        };\n    }\n\n    public InnerClass getInnerClass() {\n        return new InnerClass();\n    }\n\n    public static void main(String[] args) {\n        TestForInnerClass test = new TestForInnerClass();\n\n        InnerClass innerClass = test.getInnerClass();\n        System.out.println(innerClass.returnInnerName());\n        System.out.println(innerClass.returnOuterName());\n\n        Counter[] localInner = test.getLocalInnerClass(\"001\");\n        System.out.println(localInner[0].next());\n        System.out.println(localInner[1].next());\n\n        Counter anonymousInner = test.getAnonymousInner(\"002\");\n        System.out.println(anonymousInner.next());\n    }\n}\n```","tags":["Java"]},{"title":"简单谈匿名内部类用在工厂方法的理解","url":"/简单谈匿名内部类用在工厂方法的理解.html","content":"\n### 简单说内部类\n- 将一个类定义在另一个类的定义内部，就是内部类，而这里的另一个类被称为**外围类**（或外部类）。\n- 内部类对象被外围类（外部类）创建时，会自动拥有一个指向该外围类的引用，还包含外围类对象的信息（闭包）。这意味着，内部类可以直接操作外围类的成员，即是是私有（private）的成员属性与方法，而无需实例出外围类的对象（因为自动拥有）。\n- 由于Java的继承是单继承，而每个内部类都能够独立地继承自一个（接口的）实现，也即，内部类为外围类提供了“可以继承多个具体或抽象的类”的能力。\n- 类的实质是一种新的数据类型，创建私有（private）的内部类即同理创建一个具有新数据结构的私有成员。\n\n### 匿名内部类\n匿名内部类通过一个返回值为基类接口（向上转型）的方法创建出一个没有类名的对象。简单来看：\n\n```java\nclass A {\n    void say() {\n        System.out.println(\"I am A.\");\n    }\n}\n\npublic class B {\n    public A createA() {\n        return new A() {\n            @Override\n            public void say() {\n                System.out.println(\"I am inside B.\");\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        B b = new B();\n        A a = b.createA();\n        a.say();\n    }\n}\n\n/**\n* Output:\n* I am inside B.\n*/\n```\n匿名内部类简化了代码，由于不具有类名，匿名内部类只被使用一次。接下来看看工厂方法中使用匿名内部类以简化代码。\n\n### 工厂方法\n#### 1. 先看不使用匿名内部类实现的工厂方法\n\n```java\ninterface Cycle {\n    void ride();\n}\n\ninterface CycleFactory {\n    Cycle getCycle();\n}\n\nclass Bicycle implements Cycle {\n    @Override\n    public void ride() {\n        System.out.println(\"Bicycle rides.\");\n    }\n}\n\nclass BicycleFactory implements CycleFactory {\n    @Override\n    public Cycle getCycle() {\n        return new Bicycle();\n    }\n}\n\npublic class Factory {\n    public static void cycleConsumer(CycleFactory factory) {\n        Cycle cycle = factory.getCycle();\n        cycle.ride();\n    }\n\n    public static void main(String[] args) {\n        cycleConsumer(new BicycleFactory());\n    }\n}\n```\n\n#### 2. 再看使用了匿名内部类的工厂方法\n\n```java\ninterface Cycle {\n    void ride();\n}\n\ninterface CycleFactory {\n    Cycle getCycle();\n}\n\nclass Bicycle implements Cycle {\n    @Override\n    public void ride() {\n        System.out.println(\"Bicycle rides.\");\n    }\n\n    public static CycleFactory factory = new CycleFactory() {\n        @Override\n        public Cycle getCycle() {\n            return new Bicycle();\n        }\n    }; // 通过一个静态成员变量（类属性）来保存工厂生成的Bicycle\n}\n\npublic class Factory {\n    public static void cycleConsumer(CycleFactory factory) {\n        Cycle cycle = factory.getCycle();\n        cycle.ride();\n    }\n\n    public static void main(String[] args) {\n        cycleConsumer(Bicycle.factory); // 不需要实例工厂类\n    }\n}\n```\n\n#### 3. 对比\n- 通过在外围类中创建一个返回类型为`工厂接口（CycleFactory）`的方法，来创建一个`Bicycle`的工厂，并将该工厂用`类属性`（静态成员变量）保存，从而可以直接访问该静态成员变量以访问其工厂。\n- 工厂只需要一个，故使用匿名内部类创建工厂对象并由`类属性`保存，即可通过使用该`类属性`让工厂生产对象。","tags":["Java","设计模式"]},{"title":"简单说一下自己对封装、继承、多态的一些理解","url":"/简单说一下自己对封装、继承、多态的一些理解.html","content":"\n### 简单理解\n#### 1、封装\n封装的实质，是提供了新的数据类型。\n\n#### 2、继承\n从外部看，从父类（基类）继承得到的子类（导出类）就像一个与基类具有相同接口（非`interface`声明的接口）的新类。当创建了一个导出类的对象时，该对象就已经包含了一个基类的子对象。*继承带来了多态的便捷性。*\n\n导出类可以通过覆写（`@Override`）基类的方法，来使同一个方法根据自己特性的不同而产生不同的表现和作用。\n\n#### 3、多态\n多态，即将改变的事物与未变的事物分离开。\n\n通过继承而来的导出类，能够使用向上转型的方式，来达到**后期绑定**（也称为*动态绑定*或*运行时绑定*）。\n\n- **绑定**：将一个方法用同一个方法主体关联起来。\n- **后期绑定**：运行时根据对象的类型进行绑定。\n\n### 具体谈多态的特性\n先通过一段代码，来解释**普通类继承**、**抽象类继承**、**接口实现**分别如何实现多态。\n\n```java\nabstract class Transportation {\n    public Transportation() {\n        System.out.println(\"This is a transportation.\");\n    }\n\n    public abstract void forward();\n}\n\ninterface TransportPower {\n    void powerSource();\n}\n\nclass Car extends Transportation {\n    private wheelNum = 4;\n\n    public int getWheelNum() {\n        return wheelNum;\n    }\n\n    @Override\n    public void forward() {\n        System.out.println(\"Car goes forward.\");\n    }\n}\n\nclass OilCar extends Car implements TransportPower {\n    @Override\n    public void powerSource() {\n        System.out.println(\"Use oil as power.\");\n    }\n\n    public void highSpeed() {\n        System.out.println(\"OilCar can highSpeed.\");\n    }\n}\n```\n\n#### 1、普通类继承\n导出类不一定需要覆写基类的所有方法，导出类对象中包含了基类的子对象，故通过`getWheelNum()`方法，可以获得基类中的成员变量`wheelNum`。\n\n#### 2、抽象类继承\n抽象类的导出类必须覆写基类的抽象方法，赋予具体实现。\n\n#### 3、接口实现\n实现了某接口的类必须覆写接口中所有的方法，赋予具体实现。\n\n***所有导出类，都可以通过向上转型的方式，在运行时绑定，从而实现多态性。***\n\n### 抽象类与接口的区别\n1. 接口只能定义抽象方法，而抽象类可以定义非抽象方法。\n2. 类只能单继承，而接口可以多实现。\n\n#### 深层讲解\n参考链接：https://blog.csdn.net/aptentity/article/details/68942916\n\n- 抽象类\n    - 对类型进行隐藏，可以构造出一个固定的一组行为的抽象描述，一个行为可以有任意个可能的具体实现方式。这个抽象的描述就是抽象类。（即多态性的体现）\n    - 这一组任意个可能的具体实现表现为所有可能的导出类，模块可以操作一个抽象类，由于模块依赖于一个固定的抽象类，那么它是不允许修改的。同时通过这个抽象类进行派生，拓展此模块的行为功能。\n- 接口\n    - 接口可以补充Java只有单继承的特性，实现“多继承”。\n    - 把程序模块进行固化的契约，降低偶合。把若干功能拆分出来，按照契约来进行实现和依赖。\n    - 定义接口有利于代码的规范。\n\n***抽象类强调的是从属关系，接口强调的是功能。***","tags":["Java","面向对象"]},{"title":"如何部署Hexo博客到GitHub","url":"/如何部署Hexo博客到GitHub.html","content":"\n#### 一、准备环境\n- node.js\n- npm\n\n我的环境为MacOS环境。\n\n#### 二、安装hexo框架\n1. 切换到root用户\n```text\nsudo su\n```\n\n2. 安装npm淘宝源cnpm\n```text\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n3. 安装hexo\n```text\ncnpm install -g hexo-cli\n```\n\n#### 三、搭建博客\n1. 新建博客文件夹在`~`路径下\n```text\nmkdir <文件夹命名>\n```\n\n2. 初始化\n```text\nsudo hexo init\n```\n\n#### 四、启动博客\n- 用于在本地测试\n```text\nhexo s\n```\n\n#### 五、在github上新建开放仓库\n- 新建github.io仓库，必须以自己的用户名命名，如：\n```text\n<GitHub的用户名>.github.io\n```\n\n#### 六、安装git插件\n- 在博客文件夹目录下\n```text\ncnpm install --save hexo-deployer-git\n```\n\n#### 七、配置\n##### 配置推送的GitHub仓库\n- 编辑`_config.yml`文件，在最底部，配置：\n```yml\ndeploy:\n  type: git\n  repo: 仓库地址\n  branch: master\n```\n\n##### 更改主题\n1. 在`<博客根目录>`目录下，克隆主题，这里以yilia主题举例：\n```text\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n2. 配置`_config.yml`文件\n- 配置主题为yilia\n```yml\ntheme: yilia\n```\n\n#### 八、一些操作\n- 清除缓存\n```text\nhexo clean\n```\n\n- 在本地开启服务\n```text\nhexo s\n```\n\n- 推送到仓库\n```text\nhexo d\n```","tags":["环境搭建"]}]