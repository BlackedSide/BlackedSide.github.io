[{"title":"关于finally子句是否总是一定执行的问题","url":"/2020/05/25/关于finally子句是否总是一定执行的问题/","content":"\n之前在牛客上看到一道面试题，是关于“finally子句是否总是一定会被执行”。在初学Java异常章节的时候，学习到`try-catch-finally`的语句，说明了`finally`子句的用途是用于确保安全的回收资源等，因此`finally`子句总是会被系统执行。而学习到并发章节的时候，找到了一个特例。章节内容见`《Java编程思想》第21章-21.2.8-后台线程`。\n\n如下一段代码：\n```java\nclass ADaemon implements Runnable {\n    @Override\n    public void run() {\n        try {\n            System.out.println(\"Starting ADaemon\");\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            System.out.println(\"Existing via InterruptedException\");\n        } finally {\n            System.out.println(\"This should always run?\");\n        }\n    }\n}\n\npublic class DaemonsDontRunFinally {\n    public static void main(String[] atgs) throws Exception {\n        Thread t = new Thread(new ADaemon());\n        t.setDaemon(true);\n        t.start();\n    }\n}\n\n/* Output:\nStarting ADaemon\n*///:~\n```\n\n由于线程`t`被注册为后台线程，因此当执行该程序后，`finally`子句将不会得到执行，除非注释掉`setDaemon()`的调用。结合书中所述，由于非后台线程`main()`被终止时，后台线程会“**突然**”终止，即JVM会在`main()`退出后立即关闭所有后台进程，而不会有任何被希望出现的确认形式。故在这种情况下，`finally`子句将无法被执行。\n\n在牛客的面试题中，一条回答表示“当在finally子句前调用System.exit(0)”时，`finally`子句就不会被执行。即如上后台线程示例的情况一致，由于在`main()`线程中退出，其退出动作发生在`run()`中的`finally`子句之前，故`finally`子句将不会被执行。\n\n关于这个问题涉及到JVM的运行机制以及线程等问题，在此先留题占坑，等待后续学习到更加清晰的原因时再来补充解释。（2020.5.25）","tags":["Java"]},{"title":"简单说Java中接口和抽象类的区别","url":"/2020/05/10/简单说Java中接口和抽象类的区别/","content":"\n>本文参考自——牛客题库-Java校招面试题汇总\n\n### 从定义上说\n- 接口中所有的方法隐含的都是抽象的；而抽象类则可以同时包含抽象和非抽象的方法。\n- Java中只支持单继承。对于接口来说，类可以实现多个接口；但只能继承自一个抽象类。\n- 接口中声明的变量（成员属性）都是`final`的；而抽象类可以包含`非final`的变量（成员属性）。\n- 接口中的成员函数（成员方法）默认是`public`的；而抽象类的成员函数（成员方法）可以是`private`、`protected`和`public`。\n- 接口是绝对抽象的，不可以被实例化；抽象类也不可以被实例化。\n- 类可以不实现抽象类和接口中声明的所有方法，但在此情况下，该类必须得声明为抽象类。\n- 基于上一条，抽象类可以在不提供接口方法实现的情况下实现接口。即，普通类实现了一个接口，则必须给出该接口内所有方法的具体实现；而抽象类实现接口，可以不在该抽象类内部给出接口中方法的实现，但若某普通类继承自该抽象类，必须给出该接口中所有方法的具体实现。代码如下：\n```java\ninterface A {\n    void f();\n}\n\nabstract class B implements A {\n    public abstract void g();\n}\n\npublic class C extends B {\n    /**\n    * 这里的f()方法必须被声明为public的，因为接口中的方法签名默认为public\n    */\n    @Override\n    public void f() {\n        ...\n    }\n\n    /**\n    * 这里g()方法的访问权限不能小于原方法签名所声明的权限，如原方法声明为public，这里就不能使用protected等public以下的关键字修饰\n    */\n    @Override\n    public void g() {\n        ...\n    }\n}\n```\n\n### 从设计层面来说\n- 抽象类是对类的抽象，是一种模板设计。\n- 接口是对行为的抽象，是一种行为的规范。","tags":["Java"]},{"title":"Java链表操作中易犯的错误","url":"/2020/05/07/Java链表操作中易犯的错误/","content":"\n今天刷《剑指offer》中的链表操作的题目，在一处曾经经常出错的位置再一次犯了错误，该错误为在一个自定义的链表中，遍历链表节点的过程中，由于错误的判断语句导致的死循环。具体代码如下：\n\n```java\n/**\n* 链表节点的定义\n*/\nclass Node {\n    int val;\n    Node next;\n\n    Node(int val) {\n        this.val = val;\n    }\n}\n\n/**\n* 遍历链表的操作\n*/\npublic class LinkedList {\n    public void iterateNode(Node node) {\n        while (node != null) {\n            System.out.print(node.val + \" \");\n            if (node.next != null) { // 错误发生在此处，由于加入判断下一个节点不为空，才将next指针向后移动，所以当遍历到链表的最后一个节点时，它的下一个节点必为null，于是指针不向后移动，当前节点永不为null，发生死循环\n                node = node.next;\n            }\n        }\n    }\n}\n```\n\n其实如上代码中的遍历中，`if (node.next != null)`不仅是多余的语句，而且也是错误的语句。因为在节点初始化的过程中，`next`成员会被初始化为`null`，故在`while (node != null)`的循环判断中，可以直接判断当前节点是否为空。若遍历到链表中最后一个节点时，它的下一个节点为空节点，可以直接执行`node = node.next`来将指针后移，在下一次`while`判断后不进入循环即可正常运行。修改后的代码如下：\n\n```java\npublic void iterateNode(Node node) {\n    while (node != null) {\n        System.out.print(node.val + \" \");\n        node = node.next;\n    }\n}\n```","tags":["Java","数据结构"]},{"title":"一份代码搞清楚内部类","url":"/2020/02/26/一份代码搞清楚内部类/","content":"\n最近学习神书《Java编程思想》，学习到第10章内部类的内容时，花了很久时间消化。现在基本搞懂了一些基本，用一份代码大致上总结了全章大部分内容。\n\n解释说明全部在代码中用注释标识，以供理解。\n\n```java\npackage com.blackside.chapter_10;\n\ninterface Counter {\n    int next();\n}\n\npublic class TestForInnerClass {\n    private String name = \"OuterClass\";\n    private int testCount;\n\n    private class InnerClass {\n        private String name = \"InnerClass\";\n\n        /**\n         * 当内部类与外围类具有相同名的成员属性时，如何区分？\n         * 内部类中，用this标识符指代内部类自己，用 外围类名.this 指代外围类\n         * @return\n         */\n        // 操作内部类的成员属性\n        public String returnInnerName() {\n            return this.name;\n        }\n\n        // 操作外围类的成员属性\n        public String returnOuterName() {\n            return TestForInnerClass.this.name;\n        }\n    }\n\n    /**\n     * 局部内部类\n     * 可以拥有构造器\n     * 局部内部类对象，对其外围类来说可以拥有多个，即内部类可以复用\n     * @param givenName\n     * @return\n     */\n    public Counter[] getLocalInnerClass(final String givenName) {\n        Counter[] counters = new Counter[2];\n\n        class LocalInnerClass implements Counter {\n            private String name = \"LocalInner\";\n            private int number;\n\n            // 局部内部类的构造器\n            public LocalInnerClass(int number) {\n                /**\n                 * 这里形参不允许被修改，则说明局部内部类的形参需要被定义为final\n                 */\n                this.number = number;\n//                givenName += \"Testing\";\n                System.out.println(\"I am LocalInnerClass \" + this.number + \".\");\n            }\n\n            @Override\n            public int next() {\n                System.out.print(TestForInnerClass.this.name + name + \" \" + givenName + \" \" + this.number + \" output \");\n                return testCount++;\n            }\n        }\n        // 这里，不匿名的局部内部类得到复用，可以创建多个该内部类的对象\n        counters[0] = new LocalInnerClass(1);\n        counters[1] = new LocalInnerClass(2);\n        return counters;\n    }\n\n    /**\n     * 匿名内部类\n     * 无法拥有构造器，但可以使用实例初始化的方式\n     * 匿名内部类对象对于其外围类，只能拥有一个，匿名内部类无法使用多次\n     * @param givenName\n     * @return\n     */\n    public Counter getAnonymousInner(final String givenName) {\n        // 返回的匿名内部类对象一次性返回，且只产生一个对象，无法复用\n        return new Counter() {\n            private String name = \"LocalAnonymousClass\";\n\n            // 匿名内部类无法拥有构造器，这里使用实例初始化的方式\n            {\n                /**\n                 * 这里形参不允许被修改，则说明局部内部类的形参需要被定义为final\n                 */\n//                givenName += \"Testing\";\n                System.out.println(\"I am LocalAnonymousInnerClass.\"); // 匿名内部类无法拥有构造器，可以使用实例初始化的方式\n            }\n\n            @Override\n            public int next() {\n                System.out.print(TestForInnerClass.this.name + \" \" + name + \" \" + givenName + \" output \");\n                return testCount++;\n            }\n        };\n    }\n\n    public InnerClass getInnerClass() {\n        return new InnerClass();\n    }\n\n    public static void main(String[] args) {\n        TestForInnerClass test = new TestForInnerClass();\n\n        InnerClass innerClass = test.getInnerClass();\n        System.out.println(innerClass.returnInnerName());\n        System.out.println(innerClass.returnOuterName());\n\n        Counter[] localInner = test.getLocalInnerClass(\"001\");\n        System.out.println(localInner[0].next());\n        System.out.println(localInner[1].next());\n\n        Counter anonymousInner = test.getAnonymousInner(\"002\");\n        System.out.println(anonymousInner.next());\n    }\n}\n```","tags":["Java"]},{"title":"简单谈匿名内部类用在工厂方法的理解","url":"/2020/02/24/简单谈匿名内部类用在工厂方法的理解/","content":"\n### 简单说内部类\n- 将一个类定义在另一个类的定义内部，就是内部类，而这里的另一个类被称为**外围类**（或外部类）。\n- 内部类对象被外围类（外部类）创建时，会自动拥有一个指向该外围类的引用，还包含外围类对象的信息（闭包）。这意味着，内部类可以直接操作外围类的成员，即是是私有（private）的成员属性与方法，而无需实例出外围类的对象（因为自动拥有）。\n- 由于Java的继承是单继承，而每个内部类都能够独立地继承自一个（接口的）实现，也即，内部类为外围类提供了“可以继承多个具体或抽象的类”的能力。\n- 类的实质是一种新的数据类型，创建私有（private）的内部类即同理创建一个具有新数据结构的私有成员。\n\n### 匿名内部类\n匿名内部类通过一个返回值为基类接口（向上转型）的方法创建出一个没有类名的对象。简单来看：\n\n```java\nclass A {\n    void say() {\n        System.out.println(\"I am A.\");\n    }\n}\n\npublic class B {\n    public A createA() {\n        return new A() {\n            @Override\n            public void say() {\n                System.out.println(\"I am inside B.\");\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        B b = new B();\n        A a = b.createA();\n        a.say();\n    }\n}\n\n/**\n* Output:\n* I am inside B.\n*/\n```\n匿名内部类简化了代码，由于不具有类名，匿名内部类只被使用一次。接下来看看工厂方法中使用匿名内部类以简化代码。\n\n### 工厂方法\n#### 1. 先看不使用匿名内部类实现的工厂方法\n\n```java\ninterface Cycle {\n    void ride();\n}\n\ninterface CycleFactory {\n    Cycle getCycle();\n}\n\nclass Bicycle implements Cycle {\n    @Override\n    public void ride() {\n        System.out.println(\"Bicycle rides.\");\n    }\n}\n\nclass BicycleFactory implements CycleFactory {\n    @Override\n    public Cycle getCycle() {\n        return new Bicycle();\n    }\n}\n\npublic class Factory {\n    public static void cycleConsumer(CycleFactory factory) {\n        Cycle cycle = factory.getCycle();\n        cycle.ride();\n    }\n\n    public static void main(String[] args) {\n        cycleConsumer(new BicycleFactory());\n    }\n}\n```\n\n#### 2. 再看使用了匿名内部类的工厂方法\n\n```java\ninterface Cycle {\n    void ride();\n}\n\ninterface CycleFactory {\n    Cycle getCycle();\n}\n\nclass Bicycle implements Cycle {\n    @Override\n    public void ride() {\n        System.out.println(\"Bicycle rides.\");\n    }\n\n    public static CycleFactory factory = new CycleFactory() {\n        @Override\n        public Cycle getCycle() {\n            return new Bicycle();\n        }\n    }; // 通过一个静态成员变量（类属性）来保存工厂生成的Bicycle\n}\n\npublic class Factory {\n    public static void cycleConsumer(CycleFactory factory) {\n        Cycle cycle = factory.getCycle();\n        cycle.ride();\n    }\n\n    public static void main(String[] args) {\n        cycleConsumer(Bicycle.factory); // 不需要实例工厂类\n    }\n}\n```\n\n#### 3. 对比\n- 通过在外围类中创建一个返回类型为`工厂接口（CycleFactory）`的方法，来创建一个`Bicycle`的工厂，并将该工厂用`类属性`（静态成员变量）保存，从而可以直接访问该静态成员变量以访问其工厂。\n- 工厂只需要一个，故使用匿名内部类创建工厂对象并由`类属性`保存，即可通过使用该`类属性`让工厂生产对象。","tags":["Java","设计模式"]},{"title":"简单说一下自己对封装、继承、多态的一些理解","url":"/2020/02/19/简单说一下自己对封装、继承、多态的一些理解/","content":"\n### 简单理解\n#### 1、封装\n封装的实质，是提供了新的数据类型。\n\n#### 2、继承\n从外部看，从父类（基类）继承得到的子类（导出类）就像一个与基类具有相同接口（非`interface`声明的接口）的新类。当创建了一个导出类的对象时，该对象就已经包含了一个基类的子对象。*继承带来了多态的便捷性。*\n\n导出类可以通过覆写（`@Override`）基类的方法，来使同一个方法根据自己特性的不同而产生不同的表现和作用。\n\n#### 3、多态\n多态，即将改变的事物与未变的事物分离开。\n\n通过继承而来的导出类，能够使用向上转型的方式，来达到**后期绑定**（也称为*动态绑定*或*运行时绑定*）。\n\n- **绑定**：将一个方法用同一个方法主体关联起来。\n- **后期绑定**：运行时根据对象的类型进行绑定。\n\n### 具体谈多态的特性\n先通过一段代码，来解释**普通类继承**、**抽象类继承**、**接口实现**分别如何实现多态。\n\n```java\nabstract class Transportation {\n    public Transportation() {\n        System.out.println(\"This is a transportation.\");\n    }\n\n    public abstract void forward();\n}\n\ninterface TransportPower {\n    void powerSource();\n}\n\nclass Car extends Transportation {\n    private wheelNum = 4;\n\n    public int getWheelNum() {\n        return wheelNum;\n    }\n\n    @Override\n    public void forward() {\n        System.out.println(\"Car goes forward.\");\n    }\n}\n\nclass OilCar extends Car implements TransportPower {\n    @Override\n    public void powerSource() {\n        System.out.println(\"Use oil as power.\");\n    }\n\n    public void highSpeed() {\n        System.out.println(\"OilCar can highSpeed.\");\n    }\n}\n```\n\n#### 1、普通类继承\n导出类不一定需要覆写基类的所有方法，导出类对象中包含了基类的子对象，故通过`getWheelNum()`方法，可以获得基类中的成员变量`wheelNum`。\n\n#### 2、抽象类继承\n抽象类的导出类必须覆写基类的抽象方法，赋予具体实现。\n\n#### 3、接口实现\n实现了某接口的类必须覆写接口中所有的方法，赋予具体实现。\n\n***所有导出类，都可以通过向上转型的方式，在运行时绑定，从而实现多态性。***\n\n### 抽象类与接口的区别\n1. 接口只能定义抽象方法，而抽象类可以定义非抽象方法。\n2. 类只能单继承，而接口可以多实现。\n\n#### 深层讲解\n参考链接：https://blog.csdn.net/aptentity/article/details/68942916\n\n- 抽象类\n    - 对类型进行隐藏，可以构造出一个固定的一组行为的抽象描述，一个行为可以有任意个可能的具体实现方式。这个抽象的描述就是抽象类。（即多态性的体现）\n    - 这一组任意个可能的具体实现表现为所有可能的导出类，模块可以操作一个抽象类，由于模块依赖于一个固定的抽象类，那么它是不允许修改的。同时通过这个抽象类进行派生，拓展此模块的行为功能。\n- 接口\n    - 接口可以补充Java只有单继承的特性，实现“多继承”。\n    - 把程序模块进行固化的契约，降低偶合。把若干功能拆分出来，按照契约来进行实现和依赖。\n    - 定义接口有利于代码的规范。\n\n***抽象类强调的是从属关系，接口强调的是功能。***","tags":["Java","面向对象"]},{"title":"如何部署Hexo博客到GitHub","url":"/2020/02/12/如何部署Hexo博客到GitHub/","content":"\n#### 一、准备环境\n- node.js\n- npm\n\n我的环境为MacOS环境。\n\n#### 二、安装hexo框架\n1. 切换到root用户\n```text\nsudo su\n```\n\n2. 安装npm淘宝源cnpm\n```text\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n3. 安装hexo\n```text\ncnpm install -g hexo-cli\n```\n\n#### 三、搭建博客\n1. 新建博客文件夹在`~`路径下\n```text\nmkdir <文件夹命名>\n```\n\n2. 初始化\n```text\nsudo hexo init\n```\n\n#### 四、启动博客\n- 用于在本地测试\n```text\nhexo s\n```\n\n#### 五、在github上新建开放仓库\n- 新建github.io仓库，必须以自己的用户名命名，如：\n```text\n<GitHub的用户名>.github.io\n```\n\n#### 六、安装git插件\n- 在博客文件夹目录下\n```text\ncnpm install --save hexo-deployer-git\n```\n\n#### 七、配置\n##### 配置推送的GitHub仓库\n- 编辑`_config.yml`文件，在最底部，配置：\n```yml\ndeploy:\n  type: git\n  repo: 仓库地址\n  branch: master\n```\n\n##### 更改主题\n1. 在`<博客根目录>`目录下，克隆主题，这里以yilia主题举例：\n```text\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n2. 配置`_config.yml`文件\n- 配置主题为yilia\n```yml\ntheme: yilia\n```\n\n#### 八、一些操作\n- 清除缓存\n```text\nhexo clean\n```\n\n- 在本地开启服务\n```text\nhexo s\n```\n\n- 推送到仓库\n```text\nhexo d\n```","tags":["环境搭建"]}]